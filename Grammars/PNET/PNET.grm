"Name"    = 'PascalABC.NET'                             
"Version" = '1.1'
"Author"  = 'DarkStar'
"About"   = 'PascalABC.NET project'

"Case Sensitive" = False

!<%NAME%> %CODE%
!*
[TERMINALTEMPLATE]
		{
			%NAME% _%NAME%=new %NAME%(%PARAMS%);
                        
			//_%NAME%.source_context=new SourceContext(LRParser.TokenLineNumber,LRParser.TokenLinePosition,LRParser.TokenLineNumber,LRParser.TokenLinePosition+LRParser.TokenLength-1);
			_%NAME%.source_context=parsertools.GetTokenSourceContext();
			%CODE%
			return _%NAME%;
		}
*!

!%NAME%<%PARAMS%> %CODE%
!%PARAMS%=$1,$2,...
!*
[NONTERMINALTEMPLATE0]         
		{
			%NAME% _%NAME%=new %NAME%(%PARAMS%);
			parsertools.create_source_context(_%NAME%,%LEFTTOKEN%,%RIGHTTOKEN%);
			%CODE%
			return _%NAME%;
		}
*!

!add to list
!*
[NONTERMINALTEMPLATE1]         
		{
			%NAME% _%NAME%=(%NAME%)%CODE%
			return _%NAME%;
		}
*!

!*
[NONTERMINALTEMPLATE2]         
		{
			%NAME% _%NAME%;
			%CODE%
			return _%NAME%;
		}
*!


!*
[NONTERMINALTEMPLATE3]         
		{
			%NAME% _%NAME%=new %NAME%(%PARAMS%);
			%CODE%
			return _%NAME%;
		}
*!

!For BrainFuck
!*
[NONTERMINALTEMPLATE4]         
		{
			ident _ident=new ident("%NAME%");
			procedure_call _procedure_call=new procedure_call(_ident);
			parsertools.create_source_context(_ident,$1,$1);
			parsertools.create_source_context(_procedure_call,$1,$1);
                        return _procedure_call;
		}
*!

!*
[NONTERMINALTEMPLATE5]         
		{
			method_call m=new method_call();
			ident id=new ident("%NAME%");
			m.dereferencing_value=id;
			parsertools.create_source_context(id,$1,$1);
			parsertools.create_source_context(m,$1,$1);
			while_node wn=new while_node();
                        wn.expr=m;
			wn.statements=(statement_list)$2;
                        return wn;
		}
*!
                  
!for list: 
!<el>
!<list> token <el>
!*
[NONTERMINALTEMPLATE6]         
		//TemplateList for %NAME% (create)
		{
			%NAME% _%NAME%=new %NAME%();
			_%NAME%.source_context=((%CODE%)$1).source_context;
			_%NAME%.%PARAMS%.Add((%CODE%)$1);
			return _%NAME%;
		}
*!
!*
[NONTERMINALTEMPLATE7]
		//TemplateList for %NAME% (add)         
		{
			%NAME% _%NAME%=(%NAME%)$1;
			parsertools.create_source_context(_%NAME%,$$,$3);
			_%NAME%.%PARAMS%.Add($3 as %CODE%);
			return _%NAME%;
		}
*!
!*
[NONTERMINALTEMPLATE9]
                //%NAME% create
		{
			%NAME% _%NAME%=new %NAME%(%PARAMS%);
			object rt=$1;
			if($2!=null) {
				rt=$2;
				if($2 is proc_block) $$.proc_body=(proc_block)$2;
				if($2 is procedure_attribute) {
					procedure_header ph=$$.proc_header;
					if(ph.proc_attributes==null) {
						ph.proc_attributes=new procedure_attributes_list();
						parsertools.assign_source_context(ph.proc_attributes,$2);
					}
					ph.proc_attributes.proc_attributes.Add((procedure_attribute)$2);
					parsertools.create_source_context(ph.proc_attributes,ph.proc_attributes,$2);
				}
			}	
			parsertools.create_source_context($$,$1,rt);
			%CODE%
			return _%NAME%;
		}
*!


"Start Symbol" = <parse_goal>

!Comment Start =  '(*'
!Comment End   =  '*)'
 
{Ident Letter}		= {Letter} + [_]
{All ASCII}		= {#1..#256}+{Cyrillic}+{#8100..#8800}
{TextPart}		= {All ASCII} - {Control Codes}
{String Char}		= {TextPart} - ['']
{ILStringChar}		= {TextPart} - ["]
{CommentPartSlashes}	= {All ASCII} - {LF} - {CR}
{CommentPart1}		= {All ASCII} - [}]
{CommentPart2_1}	= {All ASCII} - [*]
{CommentPart2_2}	= {All ASCII} - [)] 
{Hex Digit}		= {Number} + [abcdefABCDEF]
{ILCodePart}		= {All ASCII} - [();"]

Whitespace		= ({Whitespace}+ | (('//' {CommentPartSlashes}* ({CR}{LF}|{CR})) | ('{' {CommentPart1}* '}' ) | ('(*' (  {CommentPart2_1} | '*' {CommentPart2_2}? )* '*)' ))) 


!!* parsertools.check_comment_text(this);$$=null;*!
 

tkILCode		= 'il' ({CR}{LF}|{CR}) ({ILCodePart}* | ('"'({ILStringChar}|'"""')*'"'))* 'end'		!**!

tkFloat 		= ({Number}+'.'{Number}+) | (({Number}+'.')? {Number}+ [eE] [+-]? {Number}+)  !*$$=parsertools.create_double_const(this);*!
tkIdentifier 		= ('&')? {Ident Letter} ({Ident Letter}|{Number})*	!*$$=parsertools.create_ident(this);*!
tkInteger 		= {Number}+                  	!*$$=parsertools.create_int_const(this);*!
tkHex 			= '$'{Hex Digit}+               !*$$=parsertools.create_hex_const(this);*!
tkAsciiChar 		= '#'{Number}+                  !*$$=parsertools.create_sharp_char_const(this);*!
tkStringLiteral		= ''({String Char}|'''')*''     !*$$=parsertools.create_string_const(this);*!
tkDirectiveName		= '#'{Ident Letter} ({Ident Letter}|{Number})* !*$$=parsertools.create_directive_name(this);*!
tkAddressOf 		= '@'                           !*<token_info>*!
tkAmpersend		= '&'				!*<token_info>*!
tkComma 		= ','                           !*<token_info>*!
tkColon 		= ':'                           !*<token_info>*!
tkDeref 		= '^'                           !*<token_info>*!
tkDotDot  		= '..'                          !*<token_info>*!
tkPoint 		= '.'                           !*<token_info>*!
tkRoundOpen 		= '('                           !*<token_info>*!
tkRoundClose 		= ')'                           !*<token_info>*!
tkSemiColon 		= ';'      			!*<token_info>*!	
tkSquareOpen 		= '['                           !*<token_info>*!
tkSquareClose 		= ']'                           !*<token_info>*!
tkQuestion 		= '?'                           !*<token_info>*!
tkAssign 		= ':='                          !*<op_type_node(Operators.Assignment)>*!
tkPlusEqual 		= '+='                          !*<op_type_node(Operators.AssignmentAddition)>*!
tkMinusEqual 		= '-='                          !*<op_type_node(Operators.AssignmentSubtraction)>*!
tkMultEqual 		= '*='                          !*<op_type_node(Operators.AssignmentMultiplication)>*!
tkDivEqual 		= '/='                          !*<op_type_node(Operators.AssignmentDivision)>*!
tkMinus 		= '-'				!*<op_type_node(Operators.Minus)>*!
tkPlus 			= '+'				!*<op_type_node(Operators.Plus)>*!
tkSlash 		= '/'                           !*<op_type_node(Operators.Division)>*!
tkStar 			= '*'                           !*<op_type_node(Operators.Multiplication)>*!
tkEqual 		= '='                           !*<op_type_node(Operators.Equal)>*!
tkGreater 		= '>'                           !*<op_type_node(Operators.Greater)>*!
tkGreaterEqual 		= '>='                          !*<op_type_node(Operators.GreaterEqual)>*!
tkLower 		= '<'                           !*<op_type_node(Operators.Less)>*!
tkLowerEqual 		= '<='                          !*<op_type_node(Operators.LessEqual)>*!
tkNotEqual 		= '<>'                          !*<op_type_node(Operators.NotEqual)>*!

! Reserved !
tkOr 			= 'or'                          !*<op_type_node(Operators.LogicalOR)>   $$.text=LRParser.TokenText;*!
tkXor 			= 'xor'                         !*<op_type_node(Operators.BitwiseXOR)>  $$.text=LRParser.TokenText;*!
tkAnd 			= 'and'                         !*<op_type_node(Operators.LogicalAND)>  $$.text=LRParser.TokenText;*!
tkDiv 			= 'div'                         !*<op_type_node(Operators.IntegerDivision)> $$.text=LRParser.TokenText;*!
tkMod 			= 'mod'                         !*<op_type_node(Operators.ModulusRemainder)>  $$.text=LRParser.TokenText;*!
tkShl 			= 'shl'                         !*<op_type_node(Operators.BitwiseLeftShift)>  $$.text=LRParser.TokenText;*!
tkShr 			= 'shr'                         !*<op_type_node(Operators.BitwiseRightShift)>  $$.text=LRParser.TokenText;*!
tkNot 			= 'not'                         !*<op_type_node(Operators.LogicalNOT)>  $$.text=LRParser.TokenText;*!
tkAs 			= 'as'                          !*<op_type_node(Operators.As)>   $$.text=LRParser.TokenText;*!
tkIn 			= 'in'                          !*<op_type_node(Operators.In)>   $$.text=LRParser.TokenText;*!
tkIs 			= 'is'                          !*<op_type_node(Operators.Is)>   $$.text=LRParser.TokenText;*!
tkSizeOf 		= 'sizeof'                      !*<token_info>*!
tkTypeOf 		= 'typeof'                      !*<token_info>*!
tkWhere 		= 'where'                       !*<token_info>*!
tkArray 		= 'array'                       !*<token_info>*!
tkBegin 		= 'begin'                      	!*<token_info>*!
tkCase  		= 'case'                        !*<token_info>*!
tkClass 		= 'class'                     	!*<token_info>*!
tkConst 		= 'const'                       !*<token_info>*!
tkConstructor 		= 'constructor'                 !*<token_info>*!
tkDestructor 		= 'destructor'                  !*<token_info>*!
tkDownto 		= 'downto'                      !*<token_info>*!
tkDo 			= 'do' 				!*<token_info>*!
tkElse 			= 'else'			!*<token_info>*!
tkEnd 			= 'end'				!*<token_info>*!
tkExcept  		= 'except'                      !*<token_info>*!
tkFile 			= 'file'                        !*<token_info>*!
tkFinalization 		= 'finalization'                !*<token_info>*!
tkFinally 		= 'finally'                     !*<token_info>*!
tkFor 			= 'for'				!*<token_info>*!
tkForeach               = 'foreach'                     !*<token_info>*!
tkFunction 		= 'function'         		!*<token_info>*!
tkIf 			= 'if'                          !*<token_info>*!
tkImplementation 	= 'implementation'              !*<token_info>*!
tkInherited 		= 'inherited'                   !*<token_info>*!
tkInitialization 	= 'initialization'              !*<token_info>*!
tkInterface 		= 'interface'                   !*<token_info>*!
tkProcedure 		= 'procedure'    		!*<token_info>*!
tkOperator 		= 'operator'    		!*<token_info>*!
tkProperty 		= 'property'                    !*<token_info>*!
tkRaise 		= 'raise'                       !*<token_info>*!
tkRecord 		= 'record'                      !*<token_info>*!
tkRepeat 		= 'repeat'			!*<token_info>*!
tkSet 			= 'set'                         !*<token_info>*!
tkTry 			= 'try'                         !*<token_info>*!
tkType 			= 'type'                        !*<token_info>*!
tkThen 			= 'then' 			!*<token_info>*!
tkTo 			= 'to'                          !*<token_info>*!
tkUntil 		= 'until'			!*<token_info>*!
tkUses 			= 'uses'    			!*<token_info>*!
tkUsing 		= 'using'			!*<token_info>*!
tkVar 			= 'var'				!*<token_info>*!
tkWhile			= 'while'                       !*<token_info>*!
tkWith 			= 'with'                        !*<token_info>*!
tkNil 			= 'nil'				!*<token_info>*!
tkGoto 			= 'goto'                        !*<token_info>*!
tkOf 			= 'of'             		!*<token_info>*!
tkLabel 		= 'label'   		        !*<token_info>*!
tkLock 			= 'lock'   		        !*<token_info>*!
tkProgram 		= 'program'                     !*<token_info>*!  			
tkEvent 		= 'event'                      	!*<token_info>*!  			
tkTemplate 		= 'template'                   	!*<token_info>*!  			
tkPacked 		= 'packed'
tkInline 		= 'inline' 
tkExports		= 'exports' 
tkResourceString 	= 'resourcestring'
tkThreadvar 		= 'threadvar'
tkFinal			= 'final'			!*<token_taginfo(class_attribute.Sealed)>*!


! Non Reserved !

tkAt 			= 'at'				!*<ident>*!
tkOn 			= 'on'                          !*<ident>*!
tkBF 			= 'bf'                      	!*<ident>*!
tkContains 		= 'contains'                    !*<ident>*!
tkLibrary 		= 'library'			!*<ident>*!  			
tkOut 			= 'out'                         !*<ident>*!
tkPackage 		= 'package'                     !*<ident>*!  			
tkRequires 		= 'requires'			!*<ident>*!  			
tkUnit 			= 'unit'			!*<ident>*!  			

tkShortInt 		= 'shortint'                    !*<ident>*!
tkSmallInt 		= 'smallint'                    !*<ident>*!
tkOrdInteger 		= 'integer'    			!*<ident>*!
tkByte 			= 'byte'                        !*<ident>*!
tkLongInt		= 'longint'                     !*<ident>*!
tkInt64 		= 'int64'                       !*<ident>*!
tkWord 			= 'word'                        !*<ident>*!
tkBoolean 		= 'boolean'                     !*<ident>*!
tkChar 			= 'char'                        !*<ident>*!
tkWideChar 		= 'widechar'                    !*<ident>*!
tkLongWord 		= 'longword'                    !*<ident>*!
tkPChar 		= 'pchar'                       !*<ident>*!
tkCardinal 		= 'cardinal'                    !*<ident>*!
tkReal 			= 'real'                        !*<ident>*!
tkSingle 		= 'single'                      !*<ident>*!
tkDouble 		= 'double'                      !*<ident>*!
tkExtended 		= 'extended'                    !*<ident>*!
tkComp 			= 'comp'                        !*<ident>*!
tkVariant 		= 'variant'                     !*<ident>*!
tkOleVariant 		= 'olevariant'                  !*<ident>*!
tkParams                = 'params'                      !*<ident>*!
tkObject 		= 'object'                      !*<ident>*!

tkStatic 		= 'static'   			!*<procedure_attribute(proc_attribute.attr_static)> 	$$.name=LRParser.TokenText;*!
tkAbstract 		= 'abstract'                    !*<procedure_attribute(proc_attribute.attr_abstract)> 	$$.name=LRParser.TokenText;*!
tkForward 		= 'forward'                     !*<procedure_attribute(proc_attribute.attr_forward)> 	$$.name=LRParser.TokenText;*!
tkOverload 		= 'overload'                    !*<procedure_attribute(proc_attribute.attr_overload)> 	$$.name=LRParser.TokenText;*!
tkReintroduce 		= 'reintroduce'                 !*<procedure_attribute(proc_attribute.attr_reintroduce)>$$.name=LRParser.TokenText;*!
tkOverride 		= 'override'                    !*<procedure_attribute(proc_attribute.attr_override)> 	$$.name=LRParser.TokenText;*!
tkVirtual 		= 'virtual'                     !*<procedure_attribute(proc_attribute.attr_virtual)> 	$$.name=LRParser.TokenText;*!

tkAbsolute 		= 'absolute'                    !*<ident>*!
tkAssembler 		= 'assembler'                   !*<ident>*!
tkAutomated 		= 'automated'                   !*<ident>*!                                                                                         
tkDefault 		= 'default'			!*<ident>*!
tkDispid	 	= 'dispid'                      !*<ident>*!
tkExternal 		= 'external'                    !*<ident>*!  			
tkImplements 		= 'implements'                  !*<ident>*!
tkIndex 		= 'index'			!*<ident>*!
tkMessage 		= 'message'                     !*<ident>*!
tkName 			= 'name'                        !*<ident>*!
tkNodefault 		= 'nodefault'			!*<ident>*!
tkPrivate 		= 'private'                     !*<ident>*!   
tkProtected 		= 'protected'                   !*<ident>*!
tkPublic 		= 'public'                      !*<ident>*!
tkInternal 		= 'internal'                    !*<ident>*!
tkRead 			= 'read'			!*<ident>*!
tkResident 		= 'resident'                    !*<ident>*!
tkStored 		= 'stored'                      !*<ident>*!
tkWrite 		= 'write'                       !*<ident>*!
tkReadOnly 		= 'readonly'                    !*<ident>*!
tkWriteOnly		= 'writeonly'                   !*<ident>*!

tkParseModeExpression   = '<<expression>>'		

! ======================================= Rules

<parse_goal> 				
        ::= <program_file> 		
         |  <unit_file> 
         |  <parts>		
!         |  <library_file> 		
!         |  <package_file> 		

<parts>
	::= tkParseModeExpression <expr> !*$$=$2;*!

!<error_recovery>
!        ::= tkInterface 
!         |  tkImplementation 
!         |  tkVar 
!         |  tkConst 
!         |  tkType 
!         |  tkResourceString 
!         |  tkObject 
!         |  tkFunction 
!         |  tkProcedure 
!         |  tkBegin 
!         |  tkEnd 
!         |  tkSemiColon 

<opt_head_compiler_directives>
 	::=
	 |  <head_compiler_directives>

<head_compiler_directives>
	::= <one_compiler_directive>				!*$$=null;*!
	 |  <head_compiler_directives> <one_compiler_directive> !*$$=null;*!

<one_compiler_directive>
	::= tkDirectiveName tkIdentifier       			!* {
									token_info t1 = new token_info();
									t1.text=((ident)$1).name;
					                                t1.source_context = ((ident)$1).source_context;
									token_info t2 = new token_info();
									t2.text=((ident)$2).name;
					                                t2.source_context = ((ident)$2).source_context;
									compiler_directive cd=new compiler_directive(t1,t2); 
									parsertools.create_source_context(cd,$1,$2); 
									CompilerDirectives.Add(cd); $$=null;
								}*!
	 |  tkDirectiveName tkStringLiteral       		!* {
									token_info t1 = new token_info();
									t1.text=((ident)$1).name;
					                                t1.source_context = ((ident)$1).source_context;
									token_info t2 = new token_info();
									t2.text=((string_const)$2).Value;
					                                t2.source_context = ((string_const)$2).source_context;
									compiler_directive cd=new compiler_directive(t1,t2); 
									parsertools.create_source_context(cd,$1,$2); 
									CompilerDirectives.Add(cd); $$=null;
								}*!

<program_file>
        ::= <program_heading> <opt_head_compiler_directives> <main_uses_clause> <using_clause> <program_block> tkPoint !*3program_module<$1 as program_name,(uses_list)$3,(block)$5,$4 as using_list>
									 $$.Language = LanguageId.PascalABCNET;
									 parsertools.create_source_context($$,parsertools.sc_not_null($1,$3,$4,$5),$5);	
									 *!


<program_heading> 			
        ::= 
         |  tkProgram <program_name> <program_heading_2> 	!*3program_name<(ident)$2> parsertools.create_source_context($$,$1,$2);*!

<program_heading_2>
        ::= tkSemiColon 
         |  tkRoundOpen <program_param_list> tkRoundClose tkSemiColon 

<program_name>
        ::= tkIdentifier 			

<program_param_list>
        ::= <program_param> 
         |  <program_param_list> tkComma <program_param> 

<program_param>
        ::= tkIdentifier 

<program_block>
        ::= <program_decl_sect_list> <compound_stmt>  	!*3block<null,$2 as statement_list>
							if ($1!=null) {
								$$.defs=$1 as declarations;
								parsertools.create_source_context($$,$1,$2);
							}else	
								parsertools.create_source_context($$,$2,$2);
							*!

<program_decl_sect_list>
        ::= <impl_decl_sect_list> 

<uses_clause>
	::= <main_uses_clause>
!        ::= 
!         |  tkUses <used_units_list> tkSemiColon 
!
!<used_units_list>
!        ::= <used_units_list> tkComma <used_unit_name> 
!         |  <used_unit_name>                           
!
!                                                       
!<used_unit_name>                                       
!        ::= tkIdentifier                               

<using_clause>
        ::= 
         |  <using_list>

<using_list>
	::= <using_one> <empty>                                 !*3using_list<>
								parsertools.create_source_context($$,$1,$1);
								$$.namespaces.Add((unit_or_namespace)$1);*!
	 |  <using_list> <using_one>                            !*1using_list<>$1;
								parsertools.create_source_context($$,$$,$2);
								$$.namespaces.Add((unit_or_namespace)$2);*!

<using_one>
	::=tkUsing <ident_or_keyword_pointseparator_list> tkSemiColon               !*3unit_or_namespace<(ident_list)$2> parsertools.create_source_context($$,$1,$3);*!

<ident_or_keyword_pointseparator_list>
        ::= <identifier_or_keyword> <empty>                            		!*6ident_list<idents>ident*!
         |  <ident_or_keyword_pointseparator_list> tkPoint <identifier_or_keyword>  !*7ident_list<idents>ident*!   

<main_uses_clause>
        ::= 
         |  tkUses <main_used_units_list> tkSemiColon          	!* parsertools.create_source_context($2,$1,$3);$$=$2;*!

<main_used_units_list>
        ::= <main_used_units_list> tkComma <main_used_unit_name> !*1uses_list<>$1;
								$$.units.Add((unit_or_namespace)$3);
								*!
         |  <main_used_unit_name> <empty>                              !*3uses_list<>
								$$.units.Add((unit_or_namespace)$1);
								*!

<main_used_unit_name>
        ::= <ident_or_keyword_pointseparator_list> <empty>      !*0unit_or_namespace<(ident_list)$1>*!
         |  <ident_or_keyword_pointseparator_list> tkIn tkStringLiteral !*0uses_unit_in<>
								$$.name=(ident_list)$1;
								$$.in_file=(string_const)$3;
								*!

<library_file>
        ::= <library_heading> <main_uses_clause> <library_block> tkPoint 

<library_heading>
        ::= tkLibrary tkIdentifier tkSemiColon 

<library_block>
        ::= <library_impl_decl_sect_list> <compound_stmt> 

<library_impl_decl_sect_list>
        ::= 
         |  <library_impl_decl_sect_list> <library_impl_decl_sect> 

<library_impl_decl_sect>
        ::= <label_decl_sect> 
         |  <const_decl_sect> 
         |  <res_str_decl_sect> 
         |  <type_decl_sect> 
         |  <var_decl_sect> 
         |  <proc_decl> 
         |  <func_decl> 
         |  <constructor_decl> 
         |  <destructor_decl> 
         |  <export_clause> 

<export_clause>
        ::= tkExports <exports_list> tkSemiColon 

<exports_list>
        ::= <exports_entry> 
         |  <exports_list> tkComma <exports_entry> 

<exports_entry>
        ::= <identifier> <exports_index> <exports_name> <exports_resident> 

<exports_index>
        ::= 
         |  tkIndex <integer_const> 

<exports_name>
        ::= 
         |  tkName <identifier> 
         |  tkName <literal> 

<exports_resident>
        ::= 
         |  tkResident 

<unit_file>
        ::= <unit_heading> <interface_part> <implementation_part> <initialization_part> tkPoint !*3unit_module<(unit_name)$1,(interface_node)$2,(implementation_node)$3,((initfinal_part)$4).initialization_sect,((initfinal_part)$4).finalization_sect>
								$$.Language = LanguageId.PascalABCNET;
                                                                parsertools.create_source_context($$,$1,$5);
								*!
        |   <unit_heading> <abc_interface_part> <initialization_part> tkPoint !*3unit_module<(unit_name)$1,(interface_node)$2,null,((initfinal_part)$3).initialization_sect,((initfinal_part)$3).finalization_sect>
								$$.Language = LanguageId.PascalABCNET;
                                                                parsertools.create_source_context($$,$1,$4);
								*!

<unit_heading>
        ::= <unit_key_word> <unit_name> tkSemiColon <opt_head_compiler_directives> !*3unit_name<(ident)$2,UnitHeaderKeyword.Unit> 
								if(((ident)$1).name.ToLower()=="library")
									$$.HeaderKeyword=UnitHeaderKeyword.Library;
								parsertools.create_source_context($$,$1,$3);*!

<unit_key_word>
	::= tkUnit
	 |  tkLibrary

<unit_name>
        ::= tkIdentifier 

<interface_part>
        ::= tkInterface <uses_clause> <using_clause> <int_decl_sect_list>  !*3interface_node<> 
								$$.uses_modules=$2 as uses_list;
								$$.using_namespaces=$3 as using_list;
								$$.interface_definitions=$4 as declarations;
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3,$2,$1));
								*!

<implementation_part>
        ::= tkImplementation <uses_clause> <using_clause> <impl_decl_sect_list> !*3implementation_node<>
								$$.uses_modules=$2 as uses_list;
								$$.using_namespaces=$3 as using_list;
								$$.implementation_definitions=$4 as declarations;
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3,$2,$1));
								*!
<abc_interface_part>
        ::=<uses_clause> <using_clause> <impl_decl_sect_list> 	!*3interface_node<>
								$$.uses_modules=$1 as uses_list;
								$$.using_namespaces=$2 as using_list;
								$$.interface_definitions=$3 as declarations;
								object lt=parsertools.sc_not_null($1,$2,$3);							
								object rt=parsertools.sc_not_null($3,$2,$1);							
								if (lt!=null)parsertools.create_source_context($$,lt,rt);
								*!

<initialization_part>                                           
        ::= tkEnd                                               !*3initfinal_part<>*!
         |  tkInitialization <stmt_list> tkEnd                  !*3initfinal_part<(statement_list)$2,null>
								((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
								((statement_list)$2).right_logical_bracket=(syntax_tree_node)$3;
								*!
         |  tkInitialization <stmt_list> tkFinalization <stmt_list> tkEnd !*3initfinal_part<(statement_list)$2,(statement_list)$4>
								((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
								((statement_list)$4).left_logical_bracket=(syntax_tree_node)$3;
								((statement_list)$4).right_logical_bracket=(syntax_tree_node)$5;
								*!
         |  tkBegin <stmt_list> tkEnd                           !*3initfinal_part<(statement_list)$2,null>
								((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
								((statement_list)$2).right_logical_bracket=(syntax_tree_node)$3;
								*!

<package_file>
        ::= tkPackage <package_name> tkSemiColon <requires_clause> <contains_clause> tkEnd tkPoint 

<package_name>
        ::= <identifier> 

<requires_clause>
        ::= 
         |  tkRequires 
         |  tkRequires <main_used_units_list> tkSemiColon 

<contains_clause>
        ::= 
         |  tkContains 
         |  tkContains <main_used_units_list> tkSemiColon 

<int_decl_sect_list>
	::= <int_decl_sect_list1> <empty>			!*if (((declarations)$1).defs.Count>0) return $1; return null;*!
<int_decl_sect_list1>
        ::= <empty> <empty>                                     !*3declarations<>*!
         |  <int_decl_sect_list1> <int_decl_sect>       !*1declarations<>$1;
							$$.defs.Add((declaration)$2);
							parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),$2);
							*!

<impl_decl_sect_list>
	::=<impl_decl_sect_list1> <empty>                      !*if (((declarations)$1).defs.Count>0) return $1; return null;*!
<impl_decl_sect_list1>
        ::= <empty> <empty>      			      	!*3declarations<>*!
         |  <impl_decl_sect_list1> <impl_decl_sect>  	!*1declarations<>$1;
							$$.defs.Add((declaration)$2);
							parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),$2);
							*!
<abc_decl_sect_list>
	::=<abc_decl_sect_list1> <empty>	                !*if (((declarations)$1).defs.Count>0) return $1; return null;*!
<abc_decl_sect_list1>
        ::= <empty> <empty>      			      	!*3declarations<>*!
         |  <abc_decl_sect_list1> <abc_decl_sect>  	!*1declarations<>$1;
							$$.defs.Add((declaration)$2);
							parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),$2);
							*!
<int_decl_sect>
        ::= <const_decl_sect> 
         |  <res_str_decl_sect> 
         |  <type_decl_sect> 
         |  <var_decl_sect> 
         |  <int_proc_heading> 
         |  <int_func_heading> 

<impl_decl_sect>
        ::= <label_decl_sect> 
         |  <const_decl_sect> 
         |  <res_str_decl_sect> 
         |  <type_decl_sect>                            
         |  <var_decl_sect>  				
         |  <proc_decl>                                 
         |  <func_decl> 
         |  <constructor_decl> 
         |  <destructor_decl> 

<abc_decl_sect>
        ::= <label_decl_sect> 
         |  <const_decl_sect> 
         |  <res_str_decl_sect> 
         |  <type_decl_sect>                            
         |  <var_decl_sect>  				

<int_proc_heading>
        ::= <proc_heading> 
!         |  <proc_heading> <inline_directr> tkSemiColon 
         |  <proc_heading> tkForward tkSemiColon 	!*2procedure_header<> $$=($1 as procedure_header);
							if ($$.proc_attributes==null) $$.proc_attributes=new procedure_attributes_list();
							$$.proc_attributes.proc_attributes.Add((procedure_attribute)$2);
							parsertools.create_source_context($$.proc_attributes,parsertools.sc_not_null($$.proc_attributes,$2),$2);
							parsertools.create_source_context($$,$1,$2);*!
!         |  <proc_heading> <fp_directives> 

<int_func_heading>
        ::= <func_heading> 
!         |  <func_heading> <inline_directr> tkSemiColon 
         |  <func_heading> tkForward tkSemiColon        !*2procedure_header<> $$=($1 as procedure_header);
							if ($$.proc_attributes==null) $$.proc_attributes=new procedure_attributes_list();
							$$.proc_attributes.proc_attributes.Add((procedure_attribute)$2);
							parsertools.create_source_context($$.proc_attributes,parsertools.sc_not_null($$.proc_attributes,$2),$2);
							parsertools.create_source_context($$,$1,$2);*!
!         |  <func_heading> <fp_directives> 

<label_decl_sect>
        ::= tkLabel <label_list> tkSemiColon            !*3label_definitions<(ident_list)$2>
							parsertools.create_source_context($$,$1,$3);*!

<label_list>
        ::= <label_name> <empty>                               !*6ident_list<idents>ident*!
         |  <label_list> tkComma <label_name>           !*7ident_list<idents>ident*!

<label_name>
        ::= tkInteger <empty>                           !*3ident<>
								if($1 is int32_const)
									$$.name = ((int32_const)$1).val.ToString();
								else
								if($1 is int64_const)
									$$.name = ((int64_const)$1).val.ToString();
								else
									$$.name = ((uint64_const)$1).val.ToString();
								parsertools.assign_source_context($$,$1);*!
         |  tkFloat   <empty>                         	!*3ident<((double_const)$1).val.ToString()> parsertools.assign_source_context($$,$1);*!
         |  <identifier> 

<const_decl_sect>
        ::= tkConst <const_decl>                        !*3consts_definitions_list<>
							$$.const_defs.Add((const_definition)$2);
							parsertools.create_source_context($$,$1,$2);*!
         |  <const_decl_sect> <const_decl>        	!*1consts_definitions_list<>$1;
							$$.const_defs.Add((const_definition)$2);
							parsertools.create_source_context($$,$$,$2);*!

<res_str_decl_sect>
        ::= tkResourceString <const_decl> 
         |  <res_str_decl_sect> <const_decl> 

<type_decl_sect>
        ::= tkType <type_decl>                          !*3type_declarations<>
							$$.types_decl.Add((type_declaration)$2);
							parsertools.create_source_context($$,$1,$2);*!
         |  <type_decl_sect> <type_decl>        	!*1type_declarations<>$1;
							$$.types_decl.Add((type_declaration)$2);
							parsertools.create_source_context($$,$$,$2);*!

<var_decl_sect>
        ::= tkVar <var_decl>           			!*3variable_definitions<>
							$$.var_definitions.Add((var_def_statement)$2);
							parsertools.create_source_context($$,$1,$2);*!
         |  tkThreadvar <var_decl> 
         |  <var_decl_sect> <var_decl>           	!*1variable_definitions<>$1;
							$$.var_definitions.Add((var_def_statement)$2);
							parsertools.create_source_context($$,$$,$2);*!

<const_decl>
	::= <only_const_decl> tkSemiColon 		!*$$=$1;*!

<only_const_decl>
        ::= <const_name> tkEqual <init_const_expr> 	 	!*3simple_const_definition<>
								$$.const_name=(ident)$1;
								$$.const_value=(expression)$3;
								parsertools.create_source_context($$,$1,$3);*!						
         |  <const_name> tkColon <type_ref> tkEqual <typed_const> !*3typed_const_definition<>
								$$.const_name=(ident)$1;
								$$.const_type=(type_definition)$3;
								$$.const_value=(expression)$5;
								parsertools.create_source_context($$,$1,$5);*!						

<init_const_expr>
	::= <const_expr>
	 |  <array_const> 

<const_name>
        ::= <identifier> 

<const_expr>
        ::= <const_simple_expr> 
         |  <const_simple_expr> <const_relop> <const_simple_expr> 	!*0bin_expr<(expression)$1,(expression)$3,((op_type_node)$2).type>*!

<const_relop>
        ::= tkEqual 
         |  tkNotEqual 
         |  tkLower    
         |  tkGreater 
         |  tkLowerEqual 
         |  tkGreaterEqual 
         |  tkIn 

<const_simple_expr>
        ::= <const_term> 
         |  <const_simple_expr> <const_addop> <const_term> 		!*0bin_expr<(expression)$1,(expression)$3,((op_type_node)$2).type>*!

<const_addop>
        ::= tkPlus 
         |  tkMinus 
         |  tkOr 
         |  tkXor 

<const_term>
        ::= <const_factor> 
         |  <const_term> <const_mulop> <const_factor>                   !*0bin_expr<(expression)$1,(expression)$3,((op_type_node)$2).type>*!

<const_mulop>
        ::= tkStar 
         |  tkSlash 
         |  tkDiv 
         |  tkMod 
         |  tkShl 
         |  tkShr 
         |  tkAnd 

<const_factor>
        ::= <const_variable> 
         |  <const_set> 
         |  <unsigned_number> 
         |  <literal> 
         |  tkNil       <empty> 					!*3nil_const<> parsertools.create_source_context($$,$1,$1);*!
         |  tkAddressOf <const_factor>                          !*3get_address<(addressed_value)$2> parsertools.create_source_context($$,$1,$2);*!
         |  tkRoundOpen <const_expr> tkRoundClose               !* $$=$2;*!
         |  tkNot <const_factor> 				!*0un_expr<(expression)$2,((op_type_node)$1).type>*!
         |  <sign> <const_factor>                               !*0un_expr<(expression)$2,((op_type_node)$1).type>*!
         |  tkDeref <const_factor> 				!*3roof_dereference<> 
								$$.dereferencing_value=(addressed_value)$2;
								parsertools.create_source_context($$,$1,$2);*!

<const_set>
        ::= tkSquareOpen <const_elem_list> tkSquareClose 	!*3pascal_set_constant<$2 as expression_list>
								parsertools.create_source_context($$,$1,$3);*!

<sign>
        ::= tkPlus 
         |  tkMinus 

<const_variable>
        ::= <identifier> 
         |  <const_variable> <const_variable_2>         !*if ($2 is dereference) {
							  ((dereference)$2).dereferencing_value=(addressed_value)$1;
							  parsertools.create_source_context($2,$1,$2);
							}
							if ($2 is dot_node) {
							  ((dot_node)$2).left=(addressed_value)$1;
							  parsertools.create_source_context($2,$1,((dot_node)$2).right);
							}
							$$=$2;
							*!

<const_variable_2>
        ::= tkPoint <identifier_or_keyword>                                !*3dot_node<null,(addressed_value)$2>*!
         |  tkDeref <empty>                                            !*3roof_dereference<> parsertools.assign_source_context($$,$1);*!
         |  tkRoundOpen <const_func_expr_list> tkRoundClose 	!*3method_call<(expression_list)$2> parsertools.create_source_context($$,$1,$3);*!
         |  tkSquareOpen <const_elem_list> tkSquareClose      !*3indexer<(expression_list)$2> parsertools.create_source_context($$,$1,$3);*!

<const_func_expr_list>
        ::= <const_expr> <empty>                               !*6expression_list<expressions>expression*!
         |  <const_func_expr_list> tkComma <const_expr>	!*7expression_list<expressions>expression*!

<const_elem_list>
        ::= <const_elem_list1> 				
         |  

<const_elem_list1>
        ::= <const_elem> <empty>                            	!*6expression_list<expressions>expression*!
         |  <const_elem_list1> tkComma <const_elem> 	!*7expression_list<expressions>expression*!

<const_elem>
        ::= <const_expr> 
         |  <const_expr> tkDotDot <const_expr> 		!*0diapason_expr<(expression)$1,(expression)$3>*!

<unsigned_number>
        ::= tkInteger 
         |  tkHex 
         |  tkFloat 

<typed_const>
        ::= <const_expr> 
         |  <array_const> 
         |  <record_const> 

<array_const>
        ::= tkRoundOpen <typed_const_list> tkRoundClose !*3array_const<(expression_list)$2>
							parsertools.create_source_context($$,$1,$3);*!
         |  tkRoundOpen <record_const> tkRoundClose     !*$$=$2;*!
         |  tkRoundOpen <array_const> tkRoundClose      !*$$=$2;*!

<typed_const_list>
        ::= 
         |  <typed_const> tkComma <typed_const>         !*3expression_list<>
							$$.expressions.Add((expression)$1);
							$$.expressions.Add((expression)$3);
							parsertools.create_source_context($$,$1,$3);*!
         |  <typed_const_list> tkComma <typed_const>    !*1expression_list<>$1;
							parsertools.create_source_context($$,$$,$3);
							$$.expressions.Add((expression)$3);*!
<record_const>
        ::= tkRoundOpen <const_field_list> tkRoundClose !*$$=$2;*!

<const_field_list>
	::= <const_field_list_1>                        
	 |  <const_field_list_1> tkSemiColon            !*$$=$1;*!
<const_field_list_1>
        ::= <const_field>    <empty>                           	!*6record_const<rec_consts>record_const_definition*!
         |  <const_field_list_1> tkSemiColon <const_field>	!*7record_const<rec_consts>record_const_definition*!

<const_field>
        ::= <const_field_name> tkColon <typed_const>  	!*0record_const_definition<(ident)$1,(expression)$3>*!

<const_field_name>
        ::= <identifier> 

<type_decl>
        ::= <identifier> tkEqual <type_decl_type> tkSemiColon  !*0type_declaration<(ident)$1,(type_definition)$3>*!
!         |  <error> <error_recovery> 

<type_decl_type>
        ::= <type_ref>                                        
         |  tkType <type_ref>                                  !*parsertools.create_source_context($2,$1,$2);$$=$2;*!
         |  <object_type> 

<type_ref>
        ::= <simple_type> 
         |  <string_type> 
         |  <pointer_type> 
         |  <structured_type> 
         |  <procedural_type>
	 |  <template_type> 

<template_type>
	::= <simple_type_identifier> <template_type_params>     !*0template_type_reference<(named_type_reference)$1,(template_param_list)$2>*!

<template_type_params>
	::= tkLower <template_param_list> tkGreater             !*parsertools.create_source_context($2,$1,$3);$$=$2;*!

<template_param_list>
	::= <template_param> <empty>                          	!*6template_param_list<params_list>type_definition*!
	 |  <template_param_list> tkComma <template_param> 	!*7template_param_list<params_list>type_definition*!

<template_param>
	::= <simple_type_identifier>
	 |  <template_type>

<simple_type>
	::= <simple_type_identifier>
         |  <range_expr> tkDotDot <range_expr>  	!*0diapason<(expression)$1,(expression)$3>*!
         |  tkRoundOpen <enumeration_id_list> tkRoundClose !*3enum_type_definition<(enumerator_list)$2> parsertools.create_source_context($$,$1,$3);*!


<range_expr>
        ::= <range_term>                               	
         |  <range_expr> <const_addop> <range_term>     !*0bin_expr<$1 as expression,$3 as expression,((op_type_node)$2).type>*!

<range_term>
        ::= <range_factor> 
         |  <range_term> <const_mulop> <range_factor>   !*0bin_expr<$1 as expression,$3 as expression,((op_type_node)$2).type>*!

<range_factor>
        ::= <simple_type_identifier> <empty>                   !* if(((named_type_reference)$1).names.Count>0)
								$$=((named_type_reference)$1).names[0];
						 	   else
							        $$=null;
							*!
         |  <unsigned_number> 
         |  <sign> <range_factor> 			!*0un_expr<(expression)$2,((op_type_node)$1).type>*!
         |  <literal> 
!	 |  <identifier> tkRoundOpen <const_expr> tkRoundClose
         |  <range_factor> tkRoundOpen <const_elem_list> tkRoundClose !*3method_call<(expression_list)$3>
							$$.dereferencing_value=(addressed_value)$1;
							parsertools.create_source_context($$,$1,$4);
							*!
         |  tkRoundOpen <const_expr> tkRoundClose       !* $$=$2;*!

<range_methodname>                                                        
        ::= <identifier>                                        
         |  <identifier> tkPoint <identifier_or_keyword> !*0dot_node<(ident)$1,(ident)$3>*!

<simple_type_identifier>        
        ::= <identifier>        <empty>                   	!*6named_type_reference<names>ident*!
         |  <simple_type_identifier> tkPoint <identifier_or_keyword>	!*7named_type_reference<names>ident*!
!        ::= <identifier>                               !* {if ($1 is known_type_definition) return $1;
!							named_type_reference ntr=new named_type_reference(null,(ident)$1);
!							parsertools.create_source_context(ntr,$1,$1);
!							return ntr;}
!							*!
!         |  <unit_name> tkPoint <identifier>           !* {if ($3 is known_type_definition) {((known_type_definition)$3).unit_name=(ident)$1;return $3;}
!							named_type_reference ntr=new named_type_reference((ident)$1,(ident)$3);
!							parsertools.create_source_context(ntr,$1,$3);
!							return ntr;}
!							*!

<enumeration_id_list>
        ::= <enumeration_id> tkComma <enumeration_id>   !*3enumerator_list<>
                                                        $$.enumerators.Add((enumerator)$1);
                                                        $$.enumerators.Add((enumerator)$3);
							parsertools.create_source_context($$,$1,$3);
							*!   	
         |  <enumeration_id_list> tkComma <enumeration_id>!*1enumerator_list<>$1;
                                                        $$.enumerators.Add((enumerator)$3);
							parsertools.create_source_context($$,$$,$3);
							*! 
<enumeration_id>
        ::= <identifier> <empty>			!*0enumerator<$1 as ident,null>*!

<pointer_type>
        ::= tkDeref <fptype> 				!*3ref_type<(type_definition)$2> parsertools.create_source_context($$,$1,$2);*!
                            
<structured_type>
        ::= <unpacked_structured_type> 
         |  tkPacked <unpacked_structured_type> 

<unpacked_structured_type>
        ::= <array_type> 
         |  <new_record_type> 
!         |  <record_type> 
         |  <set_type> 
         |  <file_type> 

<array_type>
        ::= tkArray tkSquareOpen <simple_type_list> tkSquareClose tkOf <type_ref> !*3array_type<(indexers_types)$3,(type_definition)$6>
										parsertools.create_source_context($3,$2,$4);
										parsertools.create_source_context($$,$1,$6);
										*!
	| <unsized_array_type>

<unsized_array_type>
	::= tkArray tkOf <type_ref>                                            	!*3array_type<null,(type_definition)$3>
										parsertools.create_source_context($$,$1,$3);
										*!

<simple_type_list>
        ::= <simple_type>  <empty>                            	!*3indexers_types<>
							$$.indexers.Add((type_definition)$1);
							*!
         |  <simple_type_list> tkComma <simple_type>    !*1indexers_types<>$1;
							$$.indexers.Add((type_definition)$3);
							*!

<record_type>
        ::= tkRecord <field_list> tkEnd                 !*3record_type<(record_type_parts)$2,null> parsertools.create_source_context($$,$1,$3);*!
         |  tkRecord tkEnd                              !*3record_type<null,null> parsertools.create_source_context($$,$1,$2);*!

<field_list>                                            
        ::= <fixed_part>   <empty>                             !*3record_type_parts<(var_def_list)$1,null> parsertools.create_source_context($$,$1,$1);*!
         |  <variant_part> <empty>                             !*3record_type_parts<null,(variant_record_type)$1> parsertools.create_source_context($$,$1,$1);*!
         |  <fixed_part_2> tkSemiColon <variant_part>   !*0record_type_parts<(var_def_list)$1,(variant_record_type)$3>*!

<fixed_part>
        ::= <fixed_part_2>                            	
         |  <fixed_part_2> tkSemiColon                  !*$$=$1;*!
                                                                
<fixed_part_2>
        ::= <record_section>  <empty>                          !*6var_def_list<vars>var_def_statement*!
         |  <fixed_part_2> tkSemiColon <record_section> !*7var_def_list<vars>var_def_statement*!

<record_section>
        ::= <record_section_id_list> tkColon <type_ref> !*3var_def_statement<(ident_list)$1,(type_definition)$3,null,definition_attribute.None,false> 
							parsertools.create_source_context($$,$1,$3);
							*!
<record_section_id_list>
        ::= <record_section_id> <empty>                        	!*6ident_list<idents>ident*!
         |  <record_section_id_list> tkComma <record_section_id>!*7ident_list<idents>ident*!

<record_section_id>
        ::= <identifier> 

<variant_part>
        ::= tkCase <tag_field> tkOf <variant_list>      !*2variant_record_type<> $$=(variant_record_type)$2;
							$$.vars=$4 as variant_types;
							parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3));	
							*!

<tag_field>
        ::= <tag_field_name> <empty>                           !*3variant_record_type<(ident)$1,null,null>*!
         |  <tag_field_name> tkColon <tag_field_typename>!*3variant_record_type<(ident)$1,(type_definition)$3,null>*! 

<tag_field_name>
        ::= <identifier> 

<tag_field_typename>
        ::= <fptype> 

<variant_list>
        ::= <variant_list_2>                            
         |  <variant_list_2> tkSemiColon                !*$$=$1;*!

<variant_list_2>
        ::= <variant>        <empty>                           !*6variant_types<vars>variant_type*!
         |  <variant_list_2> tkSemiColon <variant>      !*7variant_types<vars>variant_type*!
<variant>
        ::= <case_tag_list> tkColon tkRoundOpen <variant_field_list> tkRoundClose !*3variant_type<(expression_list)$1,(record_type_parts)$4>
							parsertools.create_source_context($$,$1,$5);								
							*!

<variant_field_list>
        ::= 
         |  <field_list> 

<case_tag_list>
        ::= <const_expr_list>
!        ::= <const_expr> 
!         |  <case_tag_list> tkComma <const_expr> 

<const_expr_list>
        ::= <const_expr>     <empty>                           !*6expression_list<expressions>expression*!
         |  <const_expr_list> tkComma <const_expr> 	!*7expression_list<expressions>expression*!

<set_type>
        ::= tkSet tkOf <simple_type>    		!*3set_type_definition<(type_definition)$3>
							parsertools.create_source_context($$,$1,$3);*!

<file_type>
        ::= tkFile tkOf <type_ref> 			!*3file_type<(type_definition)$3> parsertools.create_source_context($$,$1,$3);*!
         |  tkFile              <empty>                	!*3file_type<> parsertools.assign_source_context($$,$1);*!

<string_type>
	::= tkIdentifier tkSquareOpen <const_expr> tkSquareClose  	!*3string_num_definition<(expression)$3,(ident)$1>
								parsertools.create_source_context($$,$1,$4);*!

<procedural_type>
        ::= <procedural_type_kind> 
!         |  <procedural_type_kind> <calling_conventions> 

<procedural_type_kind>
        ::= <procedural_type_decl>                              
         |  <procedural_type_decl> tkOf <identifier>           	!* if (($3 as ident).name.ToLower()=="object")
									((procedure_header)$1).of_object=true;
								else
									errors.Add(new Errors.unexpected_ident(current_file_name,(ident)$3,"object",((syntax_tree_node)$3).source_context,(syntax_tree_node)$1));
								$$=$1;*!

<procedural_type_decl>
        ::= tkProcedure <fp_list> <maybe_error>		     	!*3procedure_header<(formal_parametres)$2,null,null,false,false,null,null> 
								object rt=$1;
								if ($2!=null) rt=$2;
								parsertools.create_source_context($$,$1,rt);
								if($3!=null)
									($3 as SyntaxError).bad_node=$$;
								*!
         |  tkFunction <fp_list> tkColon <fptype> 		!*3function_header<> 
								if ($2!=null) 
		                                                  $$.parametres=(formal_parametres)$2;
								if ($4!=null) 
								  $$.return_type=(type_definition)$4;
								$$.of_object=false;
								$$.class_keyword=false;
								parsertools.create_source_context($$,$1,$4);
								*!

<maybe_error>
	::= tkColon <fptype>					!* Errors.unexpected_return_value er=new Errors.unexpected_return_value(current_file_name,((syntax_tree_node)$2).source_context,null); errors.Add(er);$$=er;*!
	 |

<object_type>
        ::= <new_object_type> 
!         |  <old_object_type> 

!<old_object_type>
!        ::= tkObject <oot_successor> <oot_component_list> <oot_privat_list> tkEnd 

<oot_privat_list>
        ::= 
         |  tkPrivate <oot_component_list> 

<oot_component_list>
        ::= 
         |  <oot_field_list> 
         |  <oot_field_list> <oot_method_list> 
         |  <oot_method_list> 

<oot_successor>
        ::= tkRoundOpen <oot_typeidentifier> tkRoundClose 

<oot_typeidentifier>
        ::= <identifier> 

<oot_field_list>
        ::= <oot_field> 
         |  <oot_field_list> <oot_field> 

<oot_field>
        ::= <oot_id_list> tkColon <type_ref> tkSemiColon 

<oot_id_list>
        ::= <oot_field_identifier> 
         |  <oot_id_list> tkComma <oot_field_identifier> 

<oot_field_identifier>
        ::= <identifier> 

<oot_method_list>
        ::= <oot_method> 
         |  <oot_method_list> <oot_method> 

<oot_method>
        ::= <oot_method_head> 

<oot_method_head>
        ::= <proc_heading> 
         |  <func_heading> 
         |  <oot_constructor_head> 
         |  <oot_destructor_head> 

<oot_constructor_head>
        ::= tkConstructor <proc_name> <fp_list> <opt_meth_modificators> 

<oot_destructor_head>
        ::= tkDestructor <proc_name> <fp_list> <opt_meth_modificators>

<new_object_type>
        ::= <not_object_type> 
!         |  <not_class_reference_type> 

!<not_class_reference_type>
!        ::= tkClass tkOf <not_object_type_identifier> 

!<not_object_type_identifier>
!        ::= <identifier> 

<not_object_type>
        ::= <class_attributes> <class_or_interface_keyword> <opt_template_arguments> <opt_base_classes> <opt_where_section> <opt_not_component_list_seq_end> !*3class_definition<$4 as named_type_reference_list,$6 as class_body,class_keyword.Class,$3 as ident_list,$5 as where_definition_list, class_attribute.None> 
									string kw=($2 as token_info).text.ToLower();
									if($1!=null)
										$$.attribute=(class_attribute)(($1 as token_taginfo).tag);
									if (kw=="record") 
										$$.keyword=class_keyword.Record;
									else
									if (kw=="interface") 
										$$.keyword=class_keyword.Interface;
									else
									if (kw=="i<>") 
										$$.keyword=class_keyword.TemplateInterface;
									else
									if (kw=="r<>") 
										$$.keyword=class_keyword.TemplateRecord;
									else
									if (kw=="c<>") 
										$$.keyword=class_keyword.TemplateClass;
									if ($$.body!=null && $$.body.class_def_blocks!=null && 
										$$.body.class_def_blocks.Count>0 && $$.body.class_def_blocks[0].access_mod==null)
									{
										if($$.keyword==class_keyword.Class)
		                        						$$.body.class_def_blocks[0].access_mod = new access_modifer_node(access_modifer.internal_modifer);
										else
											$$.body.class_def_blocks[0].access_mod = new access_modifer_node(access_modifer.none);
									}	
									parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),parsertools.sc_not_null($6,$5,$4,$3,$2,$1));*!


<new_record_type> 
	::= <record_keyword> <opt_template_arguments> <opt_base_classes> <opt_where_section> <not_component_list_seq> tkEnd	!*3class_definition<$3 as named_type_reference_list,$5 as class_body,class_keyword.Record,$2 as ident_list,$4 as where_definition_list, class_attribute.None> 
									if ($$.body!=null && $$.body.class_def_blocks!=null && 
										$$.body.class_def_blocks.Count>0 && $$.body.class_def_blocks[0].access_mod==null)
									{
		                        					$$.body.class_def_blocks[0].access_mod = new access_modifer_node(access_modifer.public_modifer);
									}	
									parsertools.create_source_context($$,$1,$6);*!

<class_attributes>
	::= tkFinal
	 |  

<class_or_interface_keyword>
	::= tkClass
	 |  tkInterface
	 |  tkTemplate                                  	!*1token_info<>$1;$$.text="c<>";*!
	 |  tkTemplate tkClass                                  !*1token_info<>$1;$$.text="c<>";parsertools.create_source_context($$,$1,$2);*!
         |  tkTemplate tkRecord					!*1token_info<>$1;$$.text="r<>";parsertools.create_source_context($$,$1,$2);*!
	 |  tkTemplate tkInterface                             	!*1token_info<>$1;$$.text="i<>";parsertools.create_source_context($$,$1,$2);*!

<record_keyword>
        ::= tkRecord

<opt_not_component_list_seq_end>
	::= 
	 |  <not_component_list_seq> tkEnd 			!*parsertools.create_source_context($1,parsertools.sc_not_null($1,$2),$2);$$=$1;*!

<opt_base_classes>
	::=
	 |  tkRoundOpen <base_classes_names_list> tkRoundClose	!*$$=$2;*!

<base_classes_names_list>
	::= <base_class_name> <empty>             		!*6named_type_reference_list<types>named_type_reference*!
	 |  <base_classes_names_list> tkComma <base_class_name> !*7named_type_reference_list<types>named_type_reference*!     	

<base_class_name>
	::= <simple_type_identifier>
	 |  <template_type>


<opt_template_arguments>
	::=
	 |  tkLower <ident_list> tkGreater 			!*$$=$2;*!

<opt_where_section>
	::=
	 |  <where_part_list>          

<where_part_list>
	::= <where_part> <empty>               !*3where_definition_list<>
				    		parsertools.create_source_context($$,$1,$1);
						$$.defs.Add((where_definition)$1);*!
	 |  <where_part_list> <where_part>     !*1where_definition_list<>$1;
						parsertools.create_source_context($$,$$,$2);
						$$.defs.Add((where_definition)$2);*!

<where_part>
	::= tkWhere <ident_list> tkColon <type_ref_and_secific_list> tkSemiColon !*3where_definition<(ident_list)$2,(type_definition_list)$4>
											parsertools.create_source_context($$,$1,$5);*!

<type_ref_and_secific_list>
	::= <type_ref_or_secific> <empty>				!*6type_definition_list<defs>type_definition*!
	 |  <type_ref_and_secific_list> tkComma <type_ref_or_secific>   !*7type_definition_list<defs>type_definition*!

<type_ref_or_secific>
	::= <type_ref>
	 |  tkClass			!*3declaration_specificator<DeclarationSpecificator.WhereDefClass, ($1 as token_info).text>
					parsertools.assign_source_context($$,$1);*!
	 |  tkRecord                    !*3declaration_specificator<DeclarationSpecificator.WhereDefValueType, ($1 as token_info).text>
					parsertools.assign_source_context($$,$1);*!
	 |  tkConstructor               !*3declaration_specificator<DeclarationSpecificator.WhereDefConstructor, ($1 as token_info).text>
					parsertools.assign_source_context($$,$1);*!

<record_component_list>
	::= <not_component_list> <empty>!*3class_body<>
					if ($1!=null) {
		                        access_modifer_node acn=new access_modifer_node(access_modifer.public_modifer);
					((class_members)$1).access_mod = acn;
					$$.class_def_blocks.Add((class_members)$1);
					parsertools.assign_source_context($$,$1);							
					}
					*!

<not_component_list_seq>
        ::= <not_component_list> <empty>    	!*3class_body<>
					if ($1!=null) {
					$$.class_def_blocks.Add((class_members)$1);
					parsertools.assign_source_context($$,$1);							
					}
					*!
         |  <not_component_list_seq> <ot_visibility_specifier> <not_component_list> !*1class_body<>$1;
					class_members cl=(class_members)$3;
					if (cl==null) 
					{	
						cl=new class_members();
						parsertools.create_source_context(cl,$2,$2);
					}
					cl.access_mod=(access_modifer_node)$2;
					$$.class_def_blocks.Add(cl);
					parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),parsertools.sc_not_null(cl,$2));							
					*!

<ot_visibility_specifier>
        ::= tkInternal 			!*3access_modifer_node<access_modifer.internal_modifer> parsertools.assign_source_context($$,$1);*!
         |  tkPublic                    !*3access_modifer_node<access_modifer.public_modifer> parsertools.assign_source_context($$,$1);*!
         |  tkProtected                 !*3access_modifer_node<access_modifer.protected_modifer> parsertools.assign_source_context($$,$1);*!
         |  tkPrivate                   !*3access_modifer_node<access_modifer.private_modifer> parsertools.assign_source_context($$,$1);*!



<not_object_type_identifier_list>                                                            
	::= <simple_type_identifier> <empty>                                          !*6named_type_reference_list<types>named_type_reference*!
	 |  <not_object_type_identifier_list> tkComma <simple_type_identifier> !*7named_type_reference_list<types>named_type_reference*!     	
!        ::= <identifier> 
!         |  <not_object_type_identifier_list> tkComma <identifier> 

<ident_list>
        ::= <identifier> <empty>                               !*6ident_list<idents>ident*!
         |  <ident_list> tkComma <identifier>    	!*7ident_list<idents>ident*!

<not_component_list>
        ::= <not_guid>                                  
         |  <not_guid> <not_component_list_1> <opt_semicolon>          !*$$=$2;*!
         |  <not_guid> <not_component_list_2>           !*$$=$2;*!
         |  <not_guid> <not_component_list_1> tkSemiColon <not_component_list_2> !*2class_members<> $$=(class_members)$2;
							for (int i=0;i<((class_members)$4).members.Count;i++)
								$$.members.Add(((class_members)$4).members[i]);
							parsertools.create_source_context($$,$2,$4);							
							*!
<opt_semicolon>
	::=
	 |  tkSemiColon

<not_guid>
        ::= 
!         |  tkSquareOpen <const_expr> tkSquareClose 

<not_component_list_1>
        ::= <filed_or_const_definition> <empty>                     !*3class_members<>
							$$.members.Add((declaration)$1);
							parsertools.assign_source_context($$,$1);							
							*!
         |  <not_component_list_1> tkSemiColon <filed_or_const_definition_or_am>!*1class_members<>$1;
							if($3 is declaration)
								$$.members.Add((declaration)$3);
							else
								($$.members[$$.members.Count-1] as var_def_statement).var_attr=definition_attribute.Static;
							parsertools.create_source_context($$,$1,$3);							
							*! 

<not_component_list_2>
        ::= <not_method_definition> <empty>                    !*3class_members<>
							$$.members.Add((declaration)$1);
							parsertools.assign_source_context($$,$1);							
							*!
         |  <not_property_definition> <empty>                  !*3class_members<>
							$$.members.Add((declaration)$1);
							parsertools.assign_source_context($$,$1);							
							*!
         |  <not_component_list_2> <not_method_definition>!*1class_members<>$1;
							$$.members.Add((declaration)$2);
							parsertools.create_source_context($$,$1,$2);							
							*! 
         |  <not_component_list_2> <not_property_definition>!*1class_members<>$1;
							$$.members.Add((declaration)$2);
							parsertools.create_source_context($$,$1,$2);							
							*! 

<filed_or_const_definition>
	::= tkConst <only_const_decl> 			!* parsertools.create_source_context($2,$1,$2); $$=$2;*!
	  | <not_field_definition> 			

<filed_or_const_definition_or_am>
	::= <filed_or_const_definition>
	  | <field_access_modifier>

<not_field_definition>
	 ::= <var_decl_part>
          |  tkEvent <var_name_list> tkColon <type_ref> !*3var_def_statement<(ident_list)$2,(type_definition)$4,null,definition_attribute.None,true>
							parsertools.create_source_context($$,$1,$4);
							*! 
!        ::= <not_field_identifier_list> tkColon <type_ref> <opt_not_field_definition_init_value>!*3var_def_statement<(ident_list)$1,(type_definition)$3,$4 as expression,definition_attribute.None,false> 
!							parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3));
!							*!

<field_access_modifier>
	::= tkStatic			

!<opt_not_field_definition_init_value>
!	::=
!	 |  tkEqual <var_init_value>			!*$$=$2;*!

!<not_field_identifier_list>
!        ::= <not_field_identifier>  <empty>                    		!*6ident_list<idents>ident*!
!         |  <not_field_identifier_list> tkComma <not_field_identifier>	!*7ident_list<idents>ident*!

!<not_field_identifier>
!        ::= <identifier> 

<not_method_definition>
        ::= <not_method_heading>
	 |  <abc_method_decl> 

<abc_method_decl>
	::= <abc_proc_decl>
	 |  <abc_func_decl>
	 |  <abc_constructor_decl>
	 |  <abc_destructor_decl>

<not_method_heading>
        ::= tkClass <proc_heading> !* ((procedure_header)$2).class_keyword=true;$$=$2;*!
         |  tkClass <func_heading> !* ((procedure_header)$2).class_keyword=true;$$=$2;*!
         |  <func_heading> 
         |  <proc_heading> 
         |  <not_constructor_heading> 
         |  <not_destructor_heading> 

<optional_qualified_identifier>
       ::=  <qualified_identifier>
	 |  

<not_constructor_heading>
        ::= tkConstructor <optional_qualified_identifier> <fp_list> <opt_meth_modificators> !*3constructor<> 
								object rt=$2;
								$$.name=$2 as method_name;
								if ($3!=null) {
								  rt=$3;
		                                                  $$.parametres=(formal_parametres)$3;
								}
								if ($4!=null) {
								  rt=$4;
								  if (((procedure_attributes_list)$4).proc_attributes.Count>0) 
									$$.proc_attributes=(procedure_attributes_list)$4;
								}
								parsertools.create_source_context($$,$1,rt);
								*!

<not_destructor_heading>
        ::= tkDestructor <optional_qualified_identifier> <fp_list> <opt_meth_modificators> !*3destructor<> 
								object rt=$2;
								$$.name=$2 as method_name;
								if ($3!=null) {
								  rt=$3;
		                                                  $$.parametres=(formal_parametres)$3;
								}
								if ($4!=null) {
								  rt=$4;
								  if (((procedure_attributes_list)$4).proc_attributes.Count>0) 
									$$.proc_attributes=(procedure_attributes_list)$4;
								}
								parsertools.create_source_context($$,$1,rt);
								*!

<qualified_identifier>
        ::= <identifier>               <empty>                         !*0method_name<null,(ident)$1,null>*!
         |  <visibility_specifier>     <empty>                         !*0method_name<null,(ident)$1,null>*!
         |  <qualified_identifier> tkPoint <identifier>                    !*{
								method_name mn=(method_name)$1;
								mn.class_name=mn.meth_name;
								mn.meth_name=(ident)$3;
								parsertools.create_source_context($1,$1,$3);
								$$=$1;
								}*!
         |  <qualified_identifier> tkPoint <visibility_specifier>          !*{
								method_name mn=(method_name)$1;
								mn.class_name=mn.meth_name;
								mn.meth_name=(ident)$3;
								parsertools.create_source_context($1,$1,$3);
								$$=$1;
								}*!

<not_property_definition>
        ::= tkProperty <qualified_identifier> <not_property_interface> <not_property_specifiers> tkSemiColon <not_array_defaultproperty> !*3simple_property<>
								$$.property_name=((method_name)$2).meth_name;
								if ($3!=null){
									$$.parameter_list=((property_interface)$3).parameter_list;
									$$.property_type=((property_interface)$3).property_type;
									$$.index_expression=((property_interface)$3).index_expression;
								}
								if ($4!=null) $$.accessors=(property_accessors)$4;
								if ($6!=null) $$.array_default=(property_array_default)$6;
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($6,$5,$4,$3,$2,$1));
								*!

<not_array_defaultproperty>
        ::= 
         |  tkDefault tkSemiColon    				!*3property_array_default<> parsertools.create_source_context($$,$1,$2);*!

<not_property_interface>
        ::= 
         |  <not_property_parameter_list> tkColon <fptype> <not_property_interface_index> !*3property_interface<>
								$$.parameter_list=(property_parameter_list)$1;
								$$.property_type=(type_definition)$3;
								$$.index_expression=(expression)$4;
								parsertools.create_source_context($$,parsertools.sc_not_null($1,$2,$3,$4),parsertools.sc_not_null($4,$3,$2,$1));
								*!

<not_property_interface_index>
        ::= 
         |  tkIndex <expr> 					!*$$=$2;*!

<not_property_parameter_list>
        ::= 
         |  tkSquareOpen <not_parameter_decl_list> tkSquareClose!*$$=$2;*!

<not_parameter_decl_list>
        ::= <not_parameter_decl>        <empty>                        	!*6property_parameter_list<parameters>property_parameter*!
         |  <not_parameter_decl_list> tkSemiColon <not_parameter_decl>	!*7property_parameter_list<parameters>property_parameter*!

<not_parameter_decl>                                            
        ::= <not_parameter_name_list> tkColon <fptype>          !*0property_parameter<(ident_list)$1,(type_definition)$3>*!
         |  tkConst <not_parameter_name_list> tkColon <fptype> 
         |  tkVar <not_parameter_name_list> tkColon <fptype> 
         |  tkOut <not_parameter_name_list> tkColon <fptype> 

<not_parameter_name_list>
	::= <ident_list>
!        ::= <not_parameter_name> 
!         |  <not_parameter_name_list> tkComma <not_parameter_name> 

!<not_parameter_name>
!        ::= <identifier> 


<opt_identifier>
	::= <identifier>
	 | 

<not_property_specifiers>
        ::= 
         |  tkReadOnly <not_property_specifiers> 
         |  tkWriteOnly <not_property_specifiers> 
!         |  tkDispid <const_expr> <not_property_specifiers> 
         |  tkDefault <const_expr> <not_property_specifiers> 
!         |  tkNodefault <not_property_specifiers> 
!         |  tkStored <const_expr> <not_property_specifiers> 
!         |  tkImplements <not_object_type_identifier_list> <not_property_specifiers> 
!         |  tkRead <expr> <not_property_specifiers> ???
!         |  tkWrite <expr> <not_property_specifiers>??? 
         |  tkRead <opt_identifier> <not_property_specifiers>  	!*2property_accessors<> 
								property_accessors _pa=$3 as property_accessors;
							        if (_pa==null) {
								_pa=new property_accessors();parsertools.create_source_context(_pa,$1,parsertools.sc_not_null($2,$1));
								}
								$$=_pa;
								if($2!=null && ((ident)$2).name.ToLower()=="write")
								{
								$$.read_accessor=new read_accessor_name(null);
								$$.write_accessor=new write_accessor_name(null);
								parsertools.create_source_context($$.read_accessor,$1,$1);
								parsertools.create_source_context($$.write_accessor,$2,$2);
								parsertools.create_source_context($$,$1,$2);
								}
								else
								{
								$$.read_accessor=new read_accessor_name((ident)$2);								
								parsertools.create_source_context($$.read_accessor,$1,parsertools.sc_not_null($2,$1));
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($3,$2,$1));
								}
								*!
         |  tkWrite <opt_identifier> <not_property_specifiers>      !*2property_accessors<> 
								property_accessors _pa=$3 as property_accessors;
							        if (_pa==null) {
								_pa=new property_accessors();parsertools.create_source_context(_pa,$1,parsertools.sc_not_null($2,$1));
								}
								$$=_pa;
								$$.write_accessor=new write_accessor_name((ident)$2);
								parsertools.create_source_context($$.write_accessor,$1,parsertools.sc_not_null($2,$1));
								parsertools.create_source_context($$,$1,_pa);
								*!

<var_decl>
	::= <var_decl_part> tkSemiColon				!*$$=$1;*!

<var_decl_part>
        ::= <var_decl_part_normal>
	 |  <var_decl_part_assign>
         |  <var_name_list> tkColon <type_ref> tkAssign <var_init_value_typed> !*0var_def_statement<(ident_list)$1,(type_definition)$3,(expression)$5,definition_attribute.None,false>*! 

<var_decl_part_in_stmt>
	::= <var_decl_part>
!        ::= <var_decl_part_normal>
!	 |  <var_decl_part_assign>
!        |  <var_name_list> tkColon <type_ref> tkAssign <var_init_value> !*0var_def_statement<(ident_list)$1,(type_definition)$3,(expression)$5,definition_attribute.None,false>*! 

<var_decl_part_assign>
	::= <var_name_list> tkAssign <var_init_value> !*0var_def_statement<(ident_list)$1,null,(expression)$3,definition_attribute.None,false>*! 

<var_decl_part_normal>
        ::= <var_name_list> tkColon <type_ref> !*0var_def_statement<(ident_list)$1,(type_definition)$3,null,definition_attribute.None,false>*! 

<var_init_value>
        ::= <expr>

<var_init_value_typed>
        ::= <typed_const> 
	 |  <new_expr>

<var_name_list>
        ::= <var_name>                  <empty>             		!*0ident_list<>
								$$.idents.Add((ident)$1);*!
         |  <var_name_list> tkComma <var_name>                  !*1ident_list<>$1;
								$$.idents.Add((ident)$3);
								parsertools.create_source_context($$,$$,$3);*!

<var_name>
        ::= <identifier> 

!<absolute_clause>
!        ::= 
!        |  tkAbsolute tkInteger tkColon tkInteger 
!        |  tkAbsolute tkHex tkColon tkHex 
!        |  tkAbsolute <declared_var_name> 

<declared_var_name>
        ::= <identifier> 

<constructor_decl>
        ::= <not_constructor_heading> <not_constructor_block_decl>	!*9procedure_definition<(procedure_header)$1,null>*! 

<abc_constructor_decl>
        ::= <not_constructor_heading> <abc_block>			!*9procedure_definition<(procedure_header)$1,null>*! 

<destructor_decl>
        ::= <not_destructor_heading> <not_constructor_block_decl>	!*9procedure_definition<(procedure_header)$1,null>*! 

<abc_destructor_decl>
        ::= <not_destructor_heading> <abc_block>			!*9procedure_definition<(procedure_header)$1,null>*! 

<not_constructor_block_decl>
        ::= <block> 
         |  <external_directr> 
         |  <asm_block> 

<proc_decl>
	::= <proc_decl_noclass>
	 |  tkClass <proc_decl_noclass>				!* (($2 as procedure_definition).proc_header as procedure_header).class_keyword=true;$$=$2;*!
<proc_decl_noclass>
        ::= <proc_heading> <proc_block>                      	!*9procedure_definition<(procedure_header)$1,null>*!

<abc_proc_decl>
	::= <abc_proc_decl_noclass>
	 |  tkClass <abc_proc_decl_noclass>			!* (($2 as procedure_definition).proc_header as procedure_header).class_keyword=true;$$=$2;*!
<abc_proc_decl_noclass>
        ::= <proc_heading> <abc_proc_block>                    	!*9procedure_definition<(procedure_header)$1,null>*!

<func_decl>
	::= <func_decl_noclass>
	 |  tkClass <func_decl_noclass>				!* (($2 as procedure_definition).proc_header as procedure_header).class_keyword=true;$$=$2;*!
<func_decl_noclass>
        ::= <func_heading> <func_block>                         !*9procedure_definition<(function_header)$1,null>*!

<abc_func_decl>
	::= <abc_func_decl_noclass>
	 |  tkClass <abc_func_decl_noclass>			!* (($2 as procedure_definition).proc_header as procedure_header).class_keyword=true;$$=$2;*!

<abc_func_decl_noclass>
        ::= <func_heading> <abc_proc_block>                     !*9procedure_definition<(function_header)$1,null>*!


<proc_heading>
        ::= tkProcedure <proc_name> <opt_template_arguments> <fp_list> <maybe_error> <opt_meth_modificators> <opt_where_section>  !*3procedure_header<null,null,(method_name)$2,false,false,(ident_list)$3,null> 
								object rt=$2;
								if ($4!=null) {
								  rt=$4;
		                                                  $$.parametres=(formal_parametres)$4;
								}
								if($5!=null)
									($5 as SyntaxError).bad_node=$$;
								if ($6!=null) {
								  rt=$6;
								  if (((procedure_attributes_list)$6).proc_attributes.Count>0) 
									$$.proc_attributes=(procedure_attributes_list)$6;
								}
								if ($7!=null) {
								  rt=$7;
								  $$.where_defs = (where_definition_list)$7;
								}
								parsertools.create_source_context($$,$1,rt);
								*!
!         |  tkProcedure <proc_name> tkEqual <qualified_identifier> tkSemiColon 
!         |  tkProcedure <proc_name> <error> <error_recovery> 

!<proc_name>
!        ::= <identifier>             <empty>                           !*0method_name<null,(ident)$1,null>*!
!         |  <visibility_specifier>   <empty>                           !*0method_name<null,(ident)$1,null>*!
!         |  <proc_name> tkPoint <identifier>                    !*{
!								method_name mn=(method_name)$1;
!								mn.class_name=mn.meth_name;
!								mn.meth_name=(ident)$3;
!								parsertools.create_source_context($1,$1,$3);
!								$$=$1;
!								}*!
!        |  <proc_name> tkPoint <visibility_specifier>          !*{
!								method_name mn=(method_name)$1;
!								mn.class_name=mn.meth_name;
!								mn.meth_name=(ident)$3;
!								parsertools.create_source_context($1,$1,$3);
!								$$=$1;
!								}*!
!

<proc_name>
	::= <func_name>

<func_name>
        ::= <func_meth_name_ident> <empty>                      	!*0method_name<null,(ident)$1,null>*!
         |  <func_class_name_ident> tkPoint <func_meth_name_ident>	!*0method_name<(ident)$1,(ident)$3,null>*!

<func_meth_name_ident>
        ::= <identifier>
	 |  <visibility_specifier>
	 |  <operator_name_ident>

<func_class_name_ident>
        ::= <identifier>
	 |  <visibility_specifier>

<func_heading>
        ::= tkFunction <func_name> <opt_template_arguments> <fp_list> tkColon <fptype> <opt_meth_modificators> <opt_where_section> !*3function_header<> 
								object rt=$2;
								$$.name=(method_name)$2;
								$$.template_args=(ident_list)$3;
								if ($4!=null) {
								  rt=$4;
		                                                  $$.parametres=(formal_parametres)$4;
								}
								if ($6!=null) {
								  rt=$6;
								  $$.return_type=(type_definition)$6;
								}
								if ($7!=null) {
								  rt=$7;
								  if (((procedure_attributes_list)$7).proc_attributes.Count>0) 
									$$.proc_attributes=(procedure_attributes_list)$7;
								}
								if ($8!=null) {
								  rt=$8;
								  $$.where_defs = (where_definition_list)$8;
								}
								$$.of_object=false;
 								$$.class_keyword=false;
								parsertools.create_source_context($$,$1,rt);
								*!
         |  tkFunction <func_name> <opt_meth_modificators>              !*3function_header<> 
								object rt=$2;
								$$.name=(method_name)$2;
								if ($3!=null) {
								  rt=$3;
								  if (((procedure_attributes_list)$3).proc_attributes.Count>0) 
									$$.proc_attributes=(procedure_attributes_list)$3;
								}
								$$.of_object=false;
 								$$.class_keyword=false;
								parsertools.create_source_context($$,$1,rt);
								*!
!         |  tkFunction <func_name> tkEqual <qualified_identifier> tkSemiColon 
!         |  tkFunction <func_name> <error> <error_recovery> 


<proc_block>
        ::= <proc_block_decl> 
!         |  <inline_directr> tkSemiColon 

<func_block>
        ::= <proc_block_decl> 
!         |  <inline_directr> tkSemiColon 

<proc_block_decl>
        ::= <block> 
         |  <external_directr> 
         |  <asm_block>
!	 |  <bf_block>
         |  tkForward tkSemiColon              			!*$$=$1;*!

<abc_proc_block>
        ::= <abc_block> 
         |  <external_directr> 

<external_directr>
	::= <abc_external_directr>
	 |  <abc_external_directr> tkSemiColon 			!*$$=$1;*!
!        ::= tkExternal <external_directr_ident> <external_directr_2> 
!         |  tkExternal <external_directr_ident> <external_directr_2> tkSemiColon 
!         |  tkExternal tkSemiColon 
!
!<external_directr_2>
!        ::= 
!         |  tkName <external_directr_ident> 
!         |  tkIndex <external_directr_3> 
!
!<external_directr_3>
!	::= tkInteger 
!         |  tkMinus tkInteger 

<external_directr_ident>
	::= <identifier>
	 |  <literal>

<abc_external_directr>
	::= tkExternal <external_directr_ident> tkName <external_directr_ident> !*3external_directive<(expression)$2,(expression)$4> 
										parsertools.create_source_context($$,$1,$4);*!
	

<asm_block>
	::= <impl_decl_sect_list> tkAsmBody tkSemiColon

<bf_block>
	::= tkBF <bf_instructions> tkEnd tkSemiColon 		!*3block<new declarations(),(statement_list)$2>
								parsertools.create_source_context($$,$1,$4);
								parsertools.create_source_context($2,$1,$3);
								parsertools.create_source_context($$.defs,$1,$1);
								//$$.defs.defs.Add()
								*!
<bf_empty_instruction>
	::= 
<bf_instructions>
	::= <bf_instructions_list>                     		
	 |  <bf_empty_instruction>  <empty>                            !*3statement_list<> $$.subnodes.Add(new empty_statement());*!
<bf_instructions_list> 
	::= <bf_instruction> <empty>                                   !*3statement_list<>
								$$.subnodes.Add((statement)$1);
								*!
	 |  <bf_instructions_list> <bf_instruction>   		!*1statement_list<>$1;
								$$.subnodes.Add((statement)$2);
								*!
<bf_instruction>  
	::= tkGreater <empty>                				!*4IncCaret<>*!			! >  Increment p
	 |  tkLower   <empty>                				!*4DecCaret<>*!			! <  Decrement p
	 |  tkPlus    <empty>          				!*4IncCaretValue<>*!		! +  Increment *p
	 |  tkMinus  	<empty>	        			!*4DecCaretValue<>*!		! -  Decrement *p
	 |  tkPoint   <empty>    					!*4WriteCaretValue<>*!		! .  Output *p
	 |  tkComma   <empty>                 				!*4ReadCaretValue<>*!		! ,  Input *p
	 |  tkSquareOpen <bf_instructions> tkSquareClose	!*5CaretValueNotNull<>*!  	![ ] 
	 |  tkDotDot  <empty>                 				!*4WriteCaretValue2<>*!  	! .. Output *p Output *p
 

<block>
        ::= <impl_decl_sect_list> <compound_stmt> tkSemiColon 	!*3block<(declarations)$1,(statement_list)$2>
								parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),$3);*!

<abc_block>
        ::= <abc_decl_sect_list> <compound_stmt> tkSemiColon  !*3block<(declarations)$1,(statement_list)$2>
								parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),$3);*!

<fp_list>
        ::= 
         |  tkRoundOpen <fp_sect_list> tkRoundClose    		!* if($2!=null) parsertools.create_source_context($2,$1,$3);
								$$=$2;*!
                                                       	
<fp_sect_list>
        ::= 
         |  <fp_sect>   <empty>                                        !*3formal_parametres<>
								$$.params_list.Add((typed_parametres)$1);
								*!
         |  <fp_sect_list> tkSemiColon <fp_sect>                !*1formal_parametres<>$1;
								$$.params_list.Add((typed_parametres)$3);	
								*!

<fp_sect>
        ::= <param_name_list> tkColon <fptype_new>              !*0typed_parametres<(ident_list)$1,(type_definition)$3,parametr_kind.none,null>*!
         |  <param_name_list> <empty>                                  !*0typed_parametres<(ident_list)$1,null,parametr_kind.none,null>*!
         |  tkVar <param_name_list> tkColon <fptype_new>        !*3typed_parametres<(ident_list)$2,(type_definition)$4,parametr_kind.var_parametr,null> parsertools.create_source_context($$,$1,$4);*!
         |  tkVar <param_name_list> <empty>                            !*3typed_parametres<(ident_list)$2,null,parametr_kind.var_parametr,null> parsertools.create_source_context($$,$1,$2);*!
         |  tkOut <param_name_list> tkColon <fptype_new>        !*3typed_parametres<(ident_list)$2,(type_definition)$4,parametr_kind.out_parametr,null> parsertools.create_source_context($$,$1,$4);*!
         |  tkOut <param_name_list> <empty>                            !*3typed_parametres<(ident_list)$2,null,parametr_kind.out_parametr,null> parsertools.create_source_context($$,$1,$2);*!
         |  tkConst <param_name_list> tkColon <fptype_new>      !*3typed_parametres<(ident_list)$2,(type_definition)$4,parametr_kind.const_parametr,null> parsertools.create_source_context($$,$1,$4);*!
         |  tkConst <param_name_list> <empty>                          !*3typed_parametres<(ident_list)$2,null,parametr_kind.const_parametr,null> parsertools.create_source_context($$,$1,$2);*!
         |  tkParams <param_name_list> tkColon <fptype_new>     !*3typed_parametres<(ident_list)$2,(type_definition)$4,parametr_kind.params_parametr,null> parsertools.create_source_context($$,$1,$4);*!
         |  tkParams <param_name_list> <empty>                         !*3typed_parametres<(ident_list)$2,null,parametr_kind.params_parametr,null> parsertools.create_source_context($$,$1,$2);*!
         |  <param_name_list> tkColon <fptype> tkAssign <const_expr> 		!*0typed_parametres<(ident_list)$1,(type_definition)$3,parametr_kind.none,(expression)$5>*!
         |  tkVar <param_name_list> tkColon <fptype> tkAssign <const_expr>	!*3typed_parametres<(ident_list)$2,(type_definition)$4,parametr_kind.var_parametr,(expression)$6> parsertools.create_source_context($$,$1,$4);*!
         |  tkOut <param_name_list> tkColon <fptype> tkAssign <const_expr>       !*3typed_parametres<(ident_list)$2,(type_definition)$4,parametr_kind.out_parametr,(expression)$6> parsertools.create_source_context($$,$1,$4);*!
         |  tkConst <param_name_list> tkColon <fptype> tkAssign <const_expr>     !*3typed_parametres<(ident_list)$2,(type_definition)$4,parametr_kind.const_parametr,(expression)$6> parsertools.create_source_context($$,$1,$4);*!

<param_name_list>
        ::= <param_name>   <empty>                                     !*6ident_list<idents>ident*!
         |  <param_name_list> tkComma <param_name>		!*7ident_list<idents>ident*!

<param_name>
        ::= <identifier> 

<fptype>                                                        
	::= <type_ref> 
!        ::= <identifier>                                        !* {if ($1 is known_type_definition) return $1;
!								named_type_reference ntr=new named_type_reference(null,(ident)$1);
!								parsertools.create_source_context(ntr,$1,$1);
!								return ntr;}
!								*!
!        |  <unit_name> tkPoint <identifier>                    !* {if ($3 is known_type_definition) {((known_type_definition)$3).unit_name=(ident)$1;return $3;}
!								named_type_reference ntr=new named_type_reference((ident)$1,(ident)$3);
!								parsertools.create_source_context(ntr,$1,$3);
!								return ntr;}
!								*!

<fptype_new>
	::= <type_ref>
	 |  tkArray tkOf tkConst                                !*3array_of_const_type_definition<> parsertools.create_source_context($$,$1,$3);*!

!        ::= <fptype> 
!         |  <fptype> tkEqual <const_expr> 
!         |  tkArray tkOf <fptype>                               !*3array_of_named_type_definition<(named_type_reference)$3> parsertools.create_source_context($$,$1,$3);*!

<stmt>
        ::= <unlabelled_stmt> 
         |  <label_name> tkColon <unlabelled_stmt> 		!*3labeled_statement<(ident)$1,(statement)$3> parsertools.create_source_context($$,$1,parsertools.sc_not_null($3,$2));*!

<unlabelled_stmt>
        ::= <empty> <empty>                                   	!*3empty_statement<>*!
         |  <assignment> 
         |  <proc_call> 
         |  <goto_stmt> 
         |  <compound_stmt> 
         |  <if_stmt> 
         |  <case_stmt> 
         |  <repeat_stmt> 
         |  <while_stmt> 
         |  <for_stmt> 
         |  <with_stmt> 
         |  <asm_stmt> 
!         |  <inline_directr> 
         |  <inherited_message>    				
         |  <try_stmt> 
         |  <raise_stmt>
	 |  <foreach_stmt>
	 |  <var_stmt>
	 |  <expr_as_stmt>
	 |  <lock_stmt>

<var_stmt>
	::= tkVar <var_decl_part_in_stmt>			!*3var_statement<$2 as var_def_statement> parsertools.create_source_context($$,$1,$2);*!


<assignment>
 	::= <var_reference> <assign_operator> <expr>            !*0assign<$1 as addressed_value,$3 as expression,((op_type_node)$2).type>*!
!        ::= <expr> tkAssign <expr>  		   		!*0assign<null,(expression)$3>
!								if ($1 is addressed_value_funcname)
!									$$.to=(addressed_value)$1;
!								else
!									errors.Add(new Errors.bad_leftside_assigment(current_file_name,((syntax_tree_node)$1).source_context,$$));
!								*!
        
<proc_call>
	::= <var_reference> <empty>                                    !*0procedure_call<$1 as addressed_value>*!
!        ::= <expr> 		       				!*0procedure_call<>
!								if ($1 is addressed_value_funcname)
!									$$.func_name=(addressed_value)$1;
!								else
!									errors.Add(new Errors.statement_expected(current_file_name,((syntax_tree_node)$1).source_context,$$));
!								*!

<goto_stmt>
        ::= tkGoto <label_name> 				!*0goto_statement<(ident)$2>*!

<compound_stmt>                                             
        ::= tkBegin <stmt_list> tkEnd 				!*
	 							parsertools.create_source_context($2,$1,$3);
								((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
								((statement_list)$2).right_logical_bracket=(syntax_tree_node)$3;
								$$=$2;
								*!
	 |  tkILCode				

<stmt_list>
        ::= <stmt> <empty>                                             !*3statement_list<>
								$$.subnodes.Add((statement)$1);
								parsertools.assign_source_context($$,$1); 
								*!
         |  <stmt_list> tkSemiColon <stmt>                      !*2statement_list<> $$=(statement_list)$1;
								$$.subnodes.Add((statement)$3);
								parsertools.create_source_context($$,$$,parsertools.sc_not_null($3,$2)); 
								*!

<if_stmt>
        ::= tkIf <expr> <if_then_else_branch>                   !*((if_node)$3).condition=(expression)$2;
								parsertools.create_source_context($3,$1,$3);
								$$=$3;
								*!

<if_then_else_branch>
        ::= tkThen <then_branch>                             	!*3if_node<null,(statement)$2,null>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($2,$1));	
								*!
         |  tkThen <then_branch> tkElse <else_branch>           !*3if_node<null,(statement)$2,(statement)$4>
								parsertools.create_source_context($$,$3,parsertools.sc_not_null($4,$3));	
								*!

<then_branch>
        ::= <stmt> 

<else_branch>
        ::= <stmt> 

<case_stmt>
        ::= tkCase <expr> tkOf <case_list> <else_case> tkEnd 	!*3case_node<(expression)$2,$4 as case_variants,$5 as statement>
								parsertools.create_source_context($$,$1,$6);*! 							

<case_list>
        ::= <case_item> <empty>                                !*3case_variants<> 
								if ($1 is case_variant)
								{
									$$.variants.Add((case_variant)$1);
									parsertools.create_source_context($$,$1,$1);
								}*!
         |  <case_list> tkSemiColon <case_item>         	!*1case_variants<>$1;
								parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),parsertools.sc_not_null($3,$2)); 							
								if ($3 is case_variant) $$.variants.Add((case_variant)$3);*!

<case_item>
        ::= <empty> <empty>                                    !*3empty_statement<>*!
         |  <case_label_list> tkColon <stmt>            	!*3case_variant<(expression_list)$1,(statement)$3> 
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($3,$2));*!

<case_label_list>
        ::= <case_label> <empty>                               !*6expression_list<expressions>expression*!
         |  <case_label_list> tkComma <case_label>      	!*7expression_list<expressions>expression*!

<case_label>
	::= <const_elem>
!        ::= <const_expr> 
!         |  <const_expr> tkDotDot <const_expr> 

<else_case>
        ::= 
         |  tkElse <stmt_list> 					!*$$=$2;*!

<repeat_stmt>
        ::= tkRepeat <stmt_list> tkUntil <expr>                	!*3repeat_node<(statement)$2,(expression)$4>
								((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
								((statement_list)$2).right_logical_bracket=(syntax_tree_node)$3;
                                                                parsertools.create_source_context($2,$1,$3);
								parsertools.create_source_context($$,$1,$4);	
								*!
<while_stmt>
        ::= tkWhile <expr> tkDo <stmt>                     	!*3while_node<(expression)$2,(statement)$4,WhileCycleType.While>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3));	
								*!
<lock_stmt>
        ::= tkLock <expr> tkDo <stmt>    			!*3lock_stmt<(expression)$2,(statement)$4>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3));	
								*!
<foreach_stmt>
        ::= tkForeach <identifier> <foreach_stmt_ident_dype_opt> tkIn <expr> tkDo <stmt> !*3foreach_stmt<(ident)$2,(type_definition)$3,(expression)$5,(statement)$7>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($7,$6));	
								*!

<foreach_stmt_ident_dype_opt>
	::= tkColon <type_ref> 					!* $$=$2; *!
	 |
           
<for_stmt>
        ::= tkFor <opt_var> <identifier> <for_stmt_decl_or_assign> <expr> <for_cycle_type> <expr> tkDo <stmt> !*3for_node<(ident)$3,(expression)$5,(expression)$7,(statement)$9,(for_cycle_type)$6,null,$4 as type_definition, $2!=null>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($9,$8));	
								*!
<opt_var>
	::= tkVar !*$$=true;*!
	 |

<for_stmt_decl_or_assign>
	::= tkAssign 
	 |  tkColon <simple_type_identifier> tkAssign 		!*$$=$2;*!

<for_cycle_type>
        ::= tkTo                           	!* $$=for_cycle_type.to; *!
         |  tkDownto                            !* $$=for_cycle_type.downto; *!

<with_stmt>
        ::= tkWith <expr_list> tkDo <stmt>        		!*3with_statement<(statement)$4,(expression_list)$2>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3));*!	

<inherited_message>
        ::= tkInherited <empty>    				!*3inherited_message<> parsertools.assign_source_context($$,$1);*!

<try_stmt>
        ::= tkTry <stmt_list> <try_handler>		!*3try_stmt<((statement_list)$2),(try_handler)$3> 
							((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
							parsertools.create_source_context($$,$1,$3);
							*! 

<try_handler>
        ::= tkFinally <stmt_list> tkEnd         	!*3try_handler_finally<(statement_list)$2> 
							((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
							((statement_list)$2).right_logical_bracket=(syntax_tree_node)$3;
							parsertools.create_source_context($$,$1,$3);*!
         |  tkExcept <exception_block> tkEnd    	!*3try_handler_except<(exception_block)$2> parsertools.create_source_context($$,$1,$3);*!

<exception_block>
        ::= <exception_handler_list> <exception_block_else_branch> 		!*3exception_block<null,(exception_handler_list)$1,(statement_list)$2>
										parsertools.create_source_context($$,$1,parsertools.sc_not_null($2,$1));*!
         |  <exception_handler_list> tkSemiColon <exception_block_else_branch>  !*3exception_block<null,(exception_handler_list)$1,(statement_list)$3>
										parsertools.create_source_context($$,$1,parsertools.sc_not_null($3,$2));*!
         |  <stmt_list> <empty>							!*3exception_block<(statement_list)$1,null,null>
										if (((syntax_tree_node)$1).source_context!=null) parsertools.assign_source_context($$,$1);*!

!!!!!SR???<exception_handler_list>
!!!!!	::= <exception_handler_list1>

<exception_handler_list>
        ::= <exception_handler>  <empty>                          		!*6exception_handler_list<handlers>exception_handler*!
         |  <exception_handler_list> tkSemiColon <exception_handler>    !*7exception_handler_list<handlers>exception_handler*!

<exception_block_else_branch>
        ::= 
         |  tkElse <stmt_list>         				!*$$=$2;*!

<exception_handler>
        ::= tkOn <exception_identifier> tkDo <stmt>             !*3exception_handler<((exception_ident)$2).variable,((exception_ident)$2).type_name,(statement)$4>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($3,$4));*!

<exception_identifier>
        ::= <exception_class_type_identifier> <empty>                  		!*0exception_ident<null,(named_type_reference)$1>*!
         |  <exception_variable> tkColon <exception_class_type_identifier>	!*0exception_ident<(ident)$1,(named_type_reference)$3>*! 

<exception_class_type_identifier>
        ::= <simple_type_identifier> 

<exception_variable>
        ::= <identifier> 

<raise_stmt>                                           	
        ::= tkRaise <empty>                                    !*3raise_stmt<> parsertools.assign_source_context($$,$1);*!
         |  tkRaise <expr>                              !*3raise_stmt<(expression)$2,null> parsertools.create_source_context($$,$1,$2);*!
         |  tkRaise <expr> tkAt <expr>                  !*3raise_stmt<(expression)$2,(expression)$4> parsertools.create_source_context($$,$1,$4);*!

<asm_stmt>
        ::= tkAsmBody 

<expr_list>
        ::= <expr> <empty>                             	!*6expression_list<expressions>expression*!
         |  <expr_list> tkComma <expr>       	  	!*7expression_list<expressions>expression*!

<expr_as_stmt>
	::= <allowable_expr_as_stmt> <empty>		!*3expression_as_statement<(expression)$1> parsertools.create_source_context($$,$1,$1);*!

<allowable_expr_as_stmt>
	::= <new_expr>

<expr>
	::= <expr_l1>
	 |  <format_expr> 

<expr_l1>
	::= <relop_expr>
	 |  <question_expr>
         |  <new_expr>


<sizeof_expr>
	::= tkSizeOf tkRoundOpen <simple_type_identifier> tkRoundClose !*3sizeof_operator<(named_type_reference)$3,null> parsertools.create_source_context($$,$1,$4);*!

<typeof_expr>
	::= tkTypeOf tkRoundOpen <simple_type_identifier> tkRoundClose !*3typeof_operator<(named_type_reference)$3> parsertools.create_source_context($$,$1,$4);*!

<question_expr>
	::= <expr_l1> tkQuestion <expr_l1> tkColon <expr_l1> 	!*3question_colon_expression<(expression)$1,(expression)$3,(expression)$5> parsertools.create_source_context($$,$1,$5);*!

<new_expr>
	::= <identifier> <simple_type_identifier> <opt_template_type_params> <opt_expr_list_with_bracket> !*
							{
							named_type_reference ntr;
							if($3!=null)
							{
							  ntr=new template_type_reference((named_type_reference)$2,(template_param_list)$3);
							  parsertools.create_source_context(ntr,$2,$3);
							}
							else
							  ntr=(named_type_reference)$2;
							new_expr newexpr=new new_expr(ntr,$4 as expression_list,false,null);
							parsertools.create_source_context(newexpr,$1,parsertools.sc_not_null($4,$3,$2));
							if (($1 as ident).name.ToLower()!="new")
								errors.Add(new Errors.PABCNETUnexpectedToken(current_file_name,";",((syntax_tree_node)$1).source_context,newexpr));
							$$=newexpr;
							}
							*!		
	 | <identifier> <array_name_for_new_expr> tkSquareOpen <expr_list> tkSquareClose !*
							{
							new_expr newexpr=new new_expr((type_definition)$2,$4 as expression_list,true,null);
							parsertools.create_source_context(newexpr,$1,$5);
							if (($1 as ident).name.ToLower()!="new")
								errors.Add(new Errors.PABCNETUnexpectedToken(current_file_name,";",((syntax_tree_node)$1).source_context,newexpr));
							$$=newexpr;
							}
							*!		

<array_name_for_new_expr>
	::= <simple_type_identifier>
	 |  <unsized_array_type>

<opt_template_type_params>
        ::= 
	 |  <template_type_params>

<opt_expr_list_with_bracket>
	::= 
	 |  tkRoundOpen <opt_expr_list> tkRoundClose !*$$=$2;*!


<relop_expr>
        ::= <simple_expr>                   				
         |  <simple_expr> <relop> <relop_expr> 	   			!*0bin_expr<(expression)$1,(expression)$3,((op_type_node)$2).type>*!

<format_expr> 
	::= <simple_expr> tkColon <simple_expr>                         !*0format_expr<(expression)$1,(expression)$3,null>*!
         |  <simple_expr> tkColon <simple_expr> tkColon <simple_expr>	!*0format_expr<(expression)$1,(expression)$3,(expression)$5>*! 

<relop>
        ::= tkEqual 
         |  tkNotEqual 
         |  tkLower 
         |  tkGreater 
         |  tkLowerEqual 
         |  tkGreaterEqual 
         |  tkIn 

<simple_expr>                                                    
        ::= <term> 
         |  <simple_expr> <addop> <term>                       	!*0bin_expr<$1 as expression,$3 as expression,((op_type_node)$2).type>*!

<addop>
        ::= tkPlus 
         |  tkMinus 
         |  tkOr 
         |  tkXor 

<typecast_op>
	::= tkAs <empty>  					!* $$=op_typecast.as_op; *!
	 |  tkIs <empty>                                        !* $$=op_typecast.is_op; *!

<term>
        ::= <factor> 
         |  <term> <mulop> <factor>                            	!*0bin_expr<$1 as expression,$3 as expression,((op_type_node)$2).type>*!
         |  <term> <typecast_op> <simple_type_identifier>      	!*0typecast_node<(addressed_value)$1,(type_definition)$3,(op_typecast)$2>
								if (!($1 is addressed_value)) 
									errors.Add(new Errors.bad_operand_type(current_file_name,((syntax_tree_node)$1).source_context,$$));
								*!

<mulop>
        ::= tkStar 
         |  tkSlash 
         |  tkDiv 
         |  tkMod 
         |  tkShl 
         |  tkShr 
         |  tkAnd 
!         |  tkAs 

<factor>        
        ::= tkNil <empty>      				!*3nil_const<> parsertools.create_source_context($$,$1,$1);*!
	 |  <literal_or_number>
         |  tkSquareOpen <elem_list> tkSquareClose      !*3pascal_set_constant<$2 as expression_list> parsertools.create_source_context($$,$1,$3);*!
         |  tkNot <factor> 				!*0un_expr<$2 as expression,((op_type_node)$1).type>*!
         |  <sign> <factor> 				!*0un_expr<$2 as expression,((op_type_node)$1).type>*!
         |  tkDeref <factor> 				!*3roof_dereference<> 
							$$.dereferencing_value=(addressed_value)$2;
							parsertools.create_source_context($$,$1,$2);*!
         |  <var_reference>
 
<literal_or_number>
        ::= <literal> 
	 |  <unsigned_number>

<var_reference>
        ::= <var_address> <variable>                    !*((get_address)$1).address_of=(addressed_value)$2;parsertools.create_source_context(NodesStack.Peek(),NodesStack.Peek(),$2);$$=NodesStack.Pop();*!
         |  <variable>
 

<var_address>
        ::= tkAddressOf <empty>                                !*3get_address<> parsertools.assign_source_context($$,$1); NodesStack.Push($$);*!
         |  <var_address> tkAddressOf                   !*3get_address<> ((get_address)$1).address_of=(addressed_value)$$;parsertools.create_source_context($$,$2,$2);*! 

<variable>
        ::= <identifier>
!         |  <identifier> tkAmpersend <template_type_params>    !*0ident_with_templateparams<(ident)$1,(template_param_list)$3> *!
	!SR!
!         |  <identifier> <template_type_params> <template_type_back_variables>        !*((template_param_list)$2).dereferencing_value=(addressed_value)$1;parsertools.create_source_context($2,$1,$2);$$=$2;*!
	 |  <operator_name_ident>
         |  tkInherited <identifier> 			!*3inherited_ident<> $$.name=((ident)$2).name; parsertools.create_source_context($$,$1,$2);*!
         |  tkRoundOpen <expr> tkRoundClose  		!*parsertools.create_source_context($2,$1,$3);$$=$2;*!
	 |  <sizeof_expr>
	 |  <typeof_expr>
         |  tkRoundOpen tkRoundClose 
         |  <literal_or_number> tkPoint <identifier_or_keyword> !*0dot_node<(addressed_value)$1,(addressed_value)$3>*!
	 |  <variable> <var_specifiers>                 !*
							if ($2 is dot_node) 
							{
							  ((dot_node)$2).left=(addressed_value)$1;
							  parsertools.create_source_context($2,$1,((dot_node)$2).right);
							}
							else
							if ($2 is template_param_list) 
							{
							  ((dot_node)(((template_param_list)$2).dereferencing_value)).left=(addressed_value)$1;
                                                          parsertools.create_source_context($2,$1,$2);
							  parsertools.create_source_context(((template_param_list)$2).dereferencing_value,$1,((template_param_list)$2).dereferencing_value);
							}
							else
							if ($2 is dereference) 
							{
							  ((dereference)$2).dereferencing_value=(addressed_value)$1;
							  parsertools.create_source_context($2,$1,$2);
							}
							else
							if ($2 is ident_with_templateparams) 
							{
								((ident_with_templateparams)$2).name=(addressed_value_funcname)$1;	
							}
							$$=$2;
							*!

<opt_expr_list>
	::= <expr_list>
	 |

<var_specifiers>
        ::= tkSquareOpen <expr_list> tkSquareClose      !*3indexer<(expression_list)$2> parsertools.create_source_context($$,$1,$3);*!
         |  tkSquareOpen tkSquareClose 
         |  tkRoundOpen <opt_expr_list> tkRoundClose !*3method_call<$2 as expression_list> parsertools.create_source_context($$,$1,$3);*!                
	 |  tkPoint <identifier_keyword_operatorname>	!*3dot_node<null,(addressed_value)$2> parsertools.create_source_context($$,$1,$2);*!             
         |  tkDeref <empty>                             !*3roof_dereference<> parsertools.assign_source_context($$,$1);*!
	 |  tkAmpersend <template_type_params>          !*3ident_with_templateparams<null,(template_param_list)$2> parsertools.create_source_context($$,$1,$2);*!
	!SR!
!         |  <point_identifier_or_keyword> <template_type_params> <template_type_back_variables>	!*((template_param_list)$2).dereferencing_value=(addressed_value)$1;$$=$2;*!

!<template_type_back_variables>
!	::= <point_identifier_or_keyword>
!	 |  <template_type_back_variables> <template_type_back_varspecifiers>
!

<template_type_back_varspecifiers>	
	::= tkRoundOpen <expr_list> tkRoundClose        !*3method_call<(expression_list)$2> parsertools.create_source_context($$,$1,$3);*!
         |  tkRoundOpen tkRoundClose                    !*3method_call<> parsertools.create_source_context($$,$1,$2);*!


<elem_list>
        ::= <elem_list1> 
         |  

<elem_list1>
        ::= <elem>      <empty>	                       	!*6expression_list<expressions>expression*!
         |  <elem_list1> tkComma <elem> 		!*7expression_list<expressions>expression*!

<elem>
        ::= <expr>    
         |  <expr> tkDotDot <expr> 			!*0diapason_expr<(expression)$1,(expression)$3>*!

!<inline_directr>
!        ::= tkInline tkRoundOpen <inline_element> tkRoundClose 

!<inline_element>
!        ::= <inline_param> 
!         |  <inline_element> tkSlash <inline_param> 

!<inline_param>
!        ::= tkLower <inline_const> 
!         |  tkGreater <inline_const> 
!         |  <inline_param_variable> 

!<inline_param_variable>
!        ::= <var_reference> 
!         |  <inline_param_variable> <sign> <inline_const> 
!         |  tkHex 

!<inline_const>
!        ::= <const_factor> 

<one_literal>
        ::= tkStringLiteral 
         |  tkAsciiChar 

<literal>
	::=<literal_list> <empty>                      !* literal_const_line lcl=(literal_const_line)$1;
	                                        if (lcl.literals.Count==1) $$=lcl.literals[0];
						$$=lcl;
						*!
<literal_list>
        ::= <one_literal> <empty>           		!*0literal_const_line<>
						$$.literals.Add((literal)$1);
						*!
         |  <literal_list> <one_literal> 	!*1literal_const_line<>$1;
						$$.literals.Add((literal)$2);
						parsertools.create_source_context($$,$$,$2);
						*!

<operator_name_ident>
	::= tkOperator <overload_operator>			!*3operator_name_ident<((op_type_node)$2).type>
								$$.name=((op_type_node)$2).text;
								parsertools.create_source_context($$,$1,$2);*!
<opt_meth_modificators>
	::= tkSemiColon                                         !*3procedure_attributes_list<> parsertools.AddModifier($$,proc_attribute.attr_overload);  parsertools.create_source_context($$,$1,$1); *!
	 |  tkSemiColon <meth_modificators> tkSemiColon		!* parsertools.AddModifier((procedure_attributes_list)$2,proc_attribute.attr_overload); $$=$2; *!

<meth_modificators>
	::= <meth_modificator>	<empty>				!*6procedure_attributes_list<proc_attributes>procedure_attribute*!
         |  <meth_modificators> tkSemiColon <meth_modificator>	!*7procedure_attributes_list<proc_attributes>procedure_attribute*!

<integer_const>
        ::= <sign> tkInteger 
         |  tkInteger 
         |  <sign> tkHex 
         |  tkHex 
         |  <identifier> 
         |  <sign> <identifier> 


<identifier>
        ::= tkIdentifier 
         |  <real_type_name> 
         |  <ord_type_name> 
         |  <variant_type_name>
	 |  <meth_modificator> 
         |  <property_specifier_directives> 
         |  <non_reserved> 
         |  <other> 

<identifier_or_keyword>
	::= <identifier>
	 |  <keyword>       		<empty>        	!*3ident<($1 as token_info).text> parsertools.create_source_context($$,$1,$1);*!
	 |  <reserved_keyword>       	<empty>        	!*3ident<($1 as token_info).text> parsertools.create_source_context($$,$1,$1);*!

<identifier_keyword_operatorname>
	::= <identifier>
	 |  <keyword>       		<empty>        	!*3ident<($1 as token_info).text> parsertools.create_source_context($$,$1,$1);*!
	 |  <operator_name_ident> 	

<real_type_name>
        ::= tkReal 
         |  tkSingle 
         |  tkDouble 
         |  tkExtended 
         |  tkComp 

<ord_type_name>
        ::= tkShortInt 
         |  tkSmallInt 
         |  tkOrdInteger 
         |  tkByte 
         |  tkLongInt 
         |  tkInt64 
         |  tkWord 
         |  tkBoolean 
         |  tkChar 
         |  tkWideChar 
         |  tkLongWord 
         |  tkPChar 
         |  tkCardinal 

<variant_type_name>
        ::= tkVariant 
         |  tkOleVariant 

<meth_modificator>
	::= tkAbstract 
         |  tkOverload          
	 |  tkReintroduce
         |  tkOverride
         |  tkVirtual 
	 |  tkStatic
!	 |  tkForward

<property_specifier_directives>
        ::= tkDefault 
         |  tkRead 
         |  tkWrite 
         |  tkStored 
         |  tkNodefault 
         |  tkImplements 
         |  tkWriteOnly 
         |  tkReadOnly 
         |  tkDispid 

<non_reserved>
        ::= tkAt 
         |  tkAbsolute 
         |  tkOn 
         |  tkName 
         |  tkIndex 
         |  tkMessage 
         |  tkContains 
         |  tkRequires 
         |  tkForward 
         |  tkOut 
	 |  tkObject 	

<visibility_specifier>
        ::= tkInternal 
         |  tkPublic 
         |  tkProtected 
         |  tkPrivate 

<other>
        ::= tkPackage 
         |  tkUnit 
         |  tkLibrary 
         |  tkExternal
	 |  tkBF 
	 |  tkParams

<keyword>
	::= <visibility_specifier> <empty> !*3token_info<($1 as ident).name> parsertools.create_source_context($$,$1,$1);*!
	 |  tkFinal
	 |  tkTemplate
	 |  tkOr
	 |  tkTypeOf
	 |  tkSizeOf
	 |  tkWhere
	 |  tkXor
	 |  tkAnd 		
	 |  tkDiv 		
	 |  tkMod 		
	 |  tkShl 		
	 |  tkShr 		
	 |  tkNot 		
	 |  tkAs 		
	 |  tkIn 		
	 |  tkIs 		
	 |  tkArray 	
	 |  tkBegin 	
	 |  tkCase  	
	 |  tkClass 	
	 |  tkConst 	
	 |  tkConstructor 	
	 |  tkDestructor 	
	 |  tkDownto 	
	 |  tkDo 		
	 |  tkElse 		
	 |  tkEnd 		
	 |  tkExcept  	
	 |  tkFile 		
	 |  tkFinalization 	
	 |  tkFinally 	
	 |  tkFor 		
	 |  tkFunction 	
	 |  tkIf
	 |  tkImplementation
	 |  tkInherited 	
	 |  tkInitialization
	 |  tkInterface 	
	 |  tkProcedure 	
	 |  tkProperty 	
	 |  tkRaise 	
	 |  tkRecord 	
	 |  tkRepeat 	
	 |  tkSet 		
	 |  tkTry 		
	 |  tkType 		
	 |  tkThen 		
	 |  tkTo 		
	 |  tkUntil 	
	 |  tkUses 		
	 |  tkUsing 	
	 |  tkVar 		
	 |  tkWhile		
	 |  tkWith 		
	 |  tkNil 		
	 |  tkGoto 		
	 |  tkOf 		
	 |  tkLabel 	
         |  tkProgram 

<reserved_keyword>
	::= tkOperator 	

<overload_operator>
	::= tkMinus
	 |  tkPlus
	 |  tkSquareOpen tkSquareClose 
	 |  tkRoundOpen tkRoundClose
	 |  tkSlash 	
	 |  tkStar 	
	 |  tkEqual 		
	 |  tkGreater 		
	 |  tkGreaterEqual 		
	 |  tkLower 		
	 |  tkLowerEqual 		
	 |  tkNotEqual 		
	 |  tkOr 			
	 |  tkXor 			
	 |  tkAnd 			
	 |  tkDiv 			
	 |  tkMod 			
	 |  tkShl 			
	 |  tkShr 			
	 |  tkNot 			
	 |  tkIn 			
	 |  tkAddressOf
	 |  tkDeref 
	 |  <assign_operator>

<assign_operator>
	::= tkAssign
	 |  tkPlusEqual
	 |  tkMinusEqual
	 |  tkMultEqual
         |  tkDivEqual



<empty>  		
	::=

<error>
	::= tkError
