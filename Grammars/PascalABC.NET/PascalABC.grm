"Name"    = 'PascalABC.NET'                             
"Version" = '1.1'
"Author"  = 'DarkStar, ibond'
"About"   = 'PascalABC.NET project'

"Case Sensitive" = False

!<%NAME%> %CODE%
!*
[TERMINALTEMPLATE]
		{
			%NAME% _%NAME%=new %NAME%(%PARAMS%);
                        
			//_%NAME%.source_context=new SourceContext(LRParser.TokenLineNumber,LRParser.TokenLinePosition,LRParser.TokenLineNumber,LRParser.TokenLinePosition+LRParser.TokenLength-1);
			_%NAME%.source_context=parsertools.GetTokenSourceContext();
			%CODE%
			return _%NAME%;
		}
*!

!%NAME%<%PARAMS%> %CODE%
!%PARAMS%=$1,$2,...
!*
[NONTERMINALTEMPLATE0]         
		{
			%NAME% _%NAME%=new %NAME%(%PARAMS%);
			parsertools.create_source_context(_%NAME%,%LEFTTOKEN%,%RIGHTTOKEN%);
			%CODE%
			return _%NAME%;
		}
*!

!add to list
!*
[NONTERMINALTEMPLATE1]         
		{
			%NAME% _%NAME%=(%NAME%)%CODE%
			return _%NAME%;
		}
*!

!*
[NONTERMINALTEMPLATE2]         
		{
			%NAME% _%NAME%;
			%CODE%
			return _%NAME%;
		}
*!


!*
[NONTERMINALTEMPLATE3]         
		{
			%NAME% _%NAME%=new %NAME%(%PARAMS%);
			%CODE%
			return _%NAME%;
		}
*!

!For BrainFuck
!*
[NONTERMINALTEMPLATE4]         
		{
			ident _ident=new ident("%NAME%");
			procedure_call _procedure_call=new procedure_call(_ident);
			parsertools.create_source_context(_ident,$1,$1);
			parsertools.create_source_context(_procedure_call,$1,$1);
                        return _procedure_call;
		}
*!

!*
[NONTERMINALTEMPLATE5]         
		{
			method_call m=new method_call();
			ident id=new ident("%NAME%");
			m.dereferencing_value=id;
			parsertools.create_source_context(id,$1,$1);
			parsertools.create_source_context(m,$1,$1);
			while_node wn=new while_node();
                        wn.expr=m;
			wn.statements=(statement_list)$2;
                        return wn;
		}
*!
                  
!for list: 
!<el>
!<list> token <el>
!*
[NONTERMINALTEMPLATE6]         
		//TemplateList for %NAME% (create)
		{
			%NAME% _%NAME%=new %NAME%();
			_%NAME%.source_context=((%CODE%)$1).source_context;
			_%NAME%.%PARAMS%.Add((%CODE%)$1);
			return _%NAME%;
		}
*!
!*
[NONTERMINALTEMPLATE7]
		//TemplateList for %NAME% (add)         
		{
			%NAME% _%NAME%=(%NAME%)$1;
			parsertools.create_source_context(_%NAME%,$$,$3);
			_%NAME%.%PARAMS%.Add($3 as %CODE%);
			return _%NAME%;
		}
*!
!*
[NONTERMINALTEMPLATE9]
                //%NAME% create
		{
			%NAME% _%NAME%=new %NAME%(%PARAMS%);
			object rt=$1;
			if($2!=null) {
				rt=$2;
				if($2 is proc_block) $$.proc_body=(proc_block)$2;
				if($2 is procedure_attribute) {
					procedure_header ph=$$.proc_header;
					if(ph.proc_attributes==null) {
						ph.proc_attributes=new procedure_attributes_list();
						parsertools.assign_source_context(ph.proc_attributes,$2);
					}
					ph.proc_attributes.proc_attributes.Add((procedure_attribute)$2);
					parsertools.create_source_context(ph.proc_attributes,ph.proc_attributes,$2);
				}
			}	
			parsertools.create_source_context($$,$1,rt);
			%CODE%
			return _%NAME%;
		}
*!


"Start Symbol" = <parse_goal>

Comment Start =  '{' !| '(*'
Comment End   =  '}' !| '*)'
Comment Line   =  '//'

{Ident Letter}		= {Letter} + [_]
{All ASCII}		= {#1..#256}+{Cyrillic}+{#8100..#8800}+{#53300..#53500}
{TextPart}		= {All ASCII} - {Control Codes}
{String Char}		= {TextPart} - ['']
{ILStringChar}		= {TextPart} - ["]
{CommentPartSlashes}	= {All ASCII} - {LF} - {CR}
{CommentPart1}		= {All ASCII} - [}]
{CommentPart2_1}	= {All ASCII} - [*]
{CommentPart2_2}	= {All ASCII} - [)] 
{Hex Digit}		= {Number} + [abcdefABCDEF]
{ILCodePart}		= {All ASCII} - [();"]

!Whitespace		= ({Whitespace}+ | (('//' {CommentPartSlashes}* ({CR}{LF}|{CR})) | ('{' {CommentPart1}* '}' ) | ('(*' (  {CommentPart2_1} | '*' {CommentPart2_2} )* '*)' ))) 
!Whitespace		= {Whitespace}+ !| (('//' {CommentPartSlashes}* ({CR}{LF}|{CR})) ) ! | ('{' {CommentPart1}* '}' ))) 
Whitespace		= {Whitespace}+ | ('(*' (  {CommentPart2_1} | '*' {CommentPart2_2} )* '*)' )

!!* parsertools.check_comment_text(this);$$=null;*!
 

tkILCode		= 'il' ({CR}{LF}|{CR}) ({ILCodePart}* | ('"'({ILStringChar}|'"""')*'"'))* 'end'		!**!

tkFloat 		= ({Number}+'.'{Number}+) | (({Number}+'.')? {Number}+ [eE] [+-]? {Number}+)  !*$$=parsertools.create_double_const(this);*!
tkIdentifier 		= ('&')? {Ident Letter} ({Ident Letter}|{Number})*	!*$$=parsertools.create_ident(this);*!
tkInteger 		= {Number}+                  	!*$$=parsertools.create_int_const(this);*!
tkHex 			= '$'{Hex Digit}+               !*$$=parsertools.create_hex_const(this);*!
tkAsciiChar 		= '#'{Number}+                  !*$$=parsertools.create_sharp_char_const(this);*!
tkStringLiteral		= ''({String Char}|'''')*''     !*$$=parsertools.create_string_const(this);*!
tkDirectiveName		= '#'{Ident Letter} ({Ident Letter}|{Number})* !*$$=parsertools.create_directive_name(this);*!
tkAddressOf 		= '@'                           !*<op_type_node(Operators.AddressOf)>*!
tkAmpersend		= '&'				!*<token_info>*!
tkComma 		= ','                           !*<token_info>*!
tkColon 		= ':'                           !*<token_info>*!
tkDeref 		= '^'                           !*<token_info>*!
tkDotDot  		= '..'                          !*<token_info>*!
tkPoint 		= '.'                           !*<token_info>*!
tkRoundOpen 		= '('                           !*<token_info>*!
tkRoundClose 		= ')'                           !*<token_info>*!
tkSemiColon 		= ';'      			!*<token_info>*!	
tkSquareOpen 		= '['                           !*<token_info>*!
tkSquareClose 		= ']'                           !*<token_info>*!
tkQuestion 		= '?'                           !*<token_info>*!
tkAssign 		= ':='                          !*<op_type_node(Operators.Assignment)>*!
tkPlusEqual 		= '+='                          !*<op_type_node(Operators.AssignmentAddition)>*!
tkMinusEqual 		= '-='                          !*<op_type_node(Operators.AssignmentSubtraction)>*!
tkMultEqual 		= '*='                          !*<op_type_node(Operators.AssignmentMultiplication)>*!
tkDivEqual 		= '/='                          !*<op_type_node(Operators.AssignmentDivision)>*!
tkMinus 		= '-'				!*<op_type_node(Operators.Minus)>*!
tkPlus 			= '+'				!*<op_type_node(Operators.Plus)>*!
tkSlash 		= '/'                           !*<op_type_node(Operators.Division)>*!
tkStar 			= '*'                           !*<op_type_node(Operators.Multiplication)>*!
tkEqual 		= '='                           !*<op_type_node(Operators.Equal)>*!
tkGreater 		= '>'                           !*<op_type_node(Operators.Greater)>*!
tkGreaterEqual 		= '>='                          !*<op_type_node(Operators.GreaterEqual)>*!
tkLower 		= '<'                           !*<op_type_node(Operators.Less)>*!
tkLowerEqual 		= '<='                          !*<op_type_node(Operators.LessEqual)>*!
tkNotEqual 		= '<>'                          !*<op_type_node(Operators.NotEqual)>*!
tkCSharpStyleOr		= '||'				!*<op_type_node(Operators.LogicalOR)>*!
tkArrow             = '->'					!*{token_info _token_info=new token_info(LRParser.TokenText);
                        
			                               //_token_info.source_context=new SourceContext(LRParser.TokenLineNumber,LRParser.TokenLinePosition,LRParser.TokenLineNumber,LRParser.TokenLinePosition+LRParser.TokenLength-1);
			                               _token_info.source_context=parsertools.GetTokenSourceContext();
                                                 pascalABC_lambda_definitions.Add(null);//tasha 7.05.2010
			                               return _token_info;}*!

! Reserved !
tkOr 			= 'or'                          !*<op_type_node(Operators.LogicalOR)>   $$.text=LRParser.TokenText;*!
tkXor 			= 'xor'                         !*<op_type_node(Operators.BitwiseXOR)>  $$.text=LRParser.TokenText;*!
tkAnd 			= 'and'                         !*<op_type_node(Operators.LogicalAND)>  $$.text=LRParser.TokenText;*!
tkDiv 			= 'div'                         !*<op_type_node(Operators.IntegerDivision)> $$.text=LRParser.TokenText;*!
tkMod 			= 'mod'                         !*<op_type_node(Operators.ModulusRemainder)>  $$.text=LRParser.TokenText;*!
tkShl 			= 'shl'                         !*<op_type_node(Operators.BitwiseLeftShift)>  $$.text=LRParser.TokenText;*!
tkShr 			= 'shr'                         !*<op_type_node(Operators.BitwiseRightShift)>  $$.text=LRParser.TokenText;*!
tkNot 			= 'not'                         !*<op_type_node(Operators.LogicalNOT)>  $$.text=LRParser.TokenText;*!
tkAs 			= 'as'                          !*<op_type_node(Operators.As)>   $$.text=LRParser.TokenText;*!
tkIn 			= 'in'                          !*<op_type_node(Operators.In)>   $$.text=LRParser.TokenText;*!
tkIs 			= 'is'                          !*<op_type_node(Operators.Is)>   $$.text=LRParser.TokenText;*!
tkSizeOf 		= 'sizeof'                      !*<token_info>*!
tkTypeOf 		= 'typeof'                      !*<token_info>*!
tkWhere 		= 'where'                       !*<token_info>*!
tkArray 		= 'array'                       !*<token_info>*!
tkBegin 		= 'begin'                      	!*<token_info>*!
tkCase  		= 'case'                        !*<token_info>*!
tkClass 		= 'class'                     	!*<token_info>*!
tkConst 		= 'const'                       !*<token_info>*!
tkConstructor 		= 'constructor'                 !*<token_info>*!
tkDestructor 		= 'destructor'                  !*<token_info>*!
tkDownto 		= 'downto'                      !*<token_info>*!
tkDo 			= 'do' 				!*<token_info>*!
tkElse 			= 'else'			!*<token_info>*!
tkEnd 			= 'end'				!*<token_info>*!
tkExcept  		= 'except'                      !*<token_info>*!
tkFile 			= 'file'                        !*<token_info>*!
tkFinalization 		= 'finalization'                !*<token_info>*!
tkFinally 		= 'finally'                     !*<token_info>*!
tkFor 			= 'for'				!*<token_info>*!
tkForeach               = 'foreach'                     !*<token_info>*!
tkFunction 		= 'function'         		!*<token_info>*!
tkIf 			= 'if'                          !*<token_info>*!
tkImplementation 	= 'implementation'              !*<token_info>*!
tkInherited 		= 'inherited'                   !*<token_info>*!
tkInitialization 	= 'initialization'              !*<token_info>*!
tkInterface 		= 'interface'                   !*<token_info>*!
tkProcedure 		= 'procedure'    		!*<token_info>*!
tkOperator 		= 'operator'    		!*<token_info>*!
tkProperty 		= 'property'                    !*<token_info>*!
tkRaise 		= 'raise'                       !*<token_info>*!
tkRecord 		= 'record'                      !*<token_info>*!
tkRepeat 		= 'repeat'			!*<token_info>*!
tkSet 			= 'set'                         !*<token_info>*!
tkTry 			= 'try'                         !*<token_info>*!
tkType 			= 'type'                        !*<token_info>*!
tkThen 			= 'then' 			!*<token_info>*!
tkTo 			= 'to'                          !*<token_info>*!
tkUntil 		= 'until'			!*<token_info>*!
tkUses 			= 'uses'    			!*<token_info>*!
tkUsing 		= '__using'			!*<token_info>*!
tkVar 			= 'var'				!*<token_info>*!
tkWhile			= 'while'                       !*<token_info>*!
tkWith 			= 'with'                        !*<token_info>*!
tkNil 			= 'nil'				!*<token_info>*!
tkGoto 			= 'goto'                        !*<token_info>*!
tkOf 			= 'of'             		!*<token_info>*!
tkLabel 		= 'label'   		        !*<token_info>*!
tkLock 			= 'lock'   		        !*<token_info>*!
tkProgram 		= 'program'                     !*<token_info>*!  			
tkEvent 		= 'event'                      	!*<token_info>*!  			
tkDefault 		= 'default'			!*<token_info>*!  			
tkTemplate 		= 'template'                   	!*<token_info>*!  			
tkPacked 		= 'packed'
tkInline 		= 'inline' 
tkExports		= 'exports' 
tkResourceString 	= 'resourcestring'
tkThreadvar 		= 'threadvar'
tkFinal			= 'final'			!*<token_taginfo(class_attribute.Sealed)>*!
tkImplicit		= 'implicit'	!*<op_type_node(Operators.Implicit)>   $$.text=LRParser.TokenText;*!
tkExplicit		= 'explicit'	!*<op_type_node(Operators.Explicit)>   $$.text=LRParser.TokenText;*!

! Non Reserved !

tkAt 			= 'at'				!*<ident>*!
tkOn 			= 'on'                          !*<ident>*!
tkContains 		= 'contains'                    !*<ident>*!
tkLibrary 		= 'library'			!*<ident>*!  			
tkOut 			= 'out'                         !*<ident>*!
tkPackage 		= 'package'                     !*<ident>*!  			
tkRequires 		= 'requires'			!*<ident>*!  			
tkUnit 			= 'unit'			!*<ident>*!  			

tkShortInt 		= 'shortint'                    !*<ident>*!
tkSmallInt 		= 'smallint'                    !*<ident>*!
tkOrdInteger 		= 'integer'    			!*<ident>*!
tkByte 			= 'byte'                        !*<ident>*!
tkLongInt		= 'longint'                     !*<ident>*!
tkInt64 		= 'int64'                       !*<ident>*!
tkWord 			= 'word'                        !*<ident>*!
tkBoolean 		= 'boolean'                     !*<ident>*!
tkChar 			= 'char'                        !*<ident>*!
tkWideChar 		= 'widechar'                    !*<ident>*!
tkLongWord 		= 'longword'                    !*<ident>*!
tkPChar 		= 'pchar'                       !*<ident>*!
tkCardinal 		= 'cardinal'                    !*<ident>*!
tkReal 			= 'real'                        !*<ident>*!
tkSingle 		= 'single'                      !*<ident>*!
tkDouble 		= 'double'                      !*<ident>*!
tkExtended 		= 'extended'                    !*<ident>*!
tkComp 			= 'comp'                        !*<ident>*!
tkVariant 		= 'variant'                     !*<ident>*!
tkOleVariant 		= 'olevariant'                  !*<ident>*!
tkParams                = 'params'                      !*<ident>*!

tkStatic 		= '__static'   			!*<procedure_attribute(proc_attribute.attr_static)> 	$$.name=LRParser.TokenText;*!
tkAbstract 		= 'abstract'                    !*<procedure_attribute(proc_attribute.attr_abstract)> 	$$.name=LRParser.TokenText;*!
tkForward 		= 'forward'                     !*<procedure_attribute(proc_attribute.attr_forward)> 	$$.name=LRParser.TokenText;*!
tkOverload 		= 'overload'                    !*<procedure_attribute(proc_attribute.attr_overload)> 	$$.name=LRParser.TokenText;*!
tkReintroduce 		= 'reintroduce'                 !*<procedure_attribute(proc_attribute.attr_reintroduce)>$$.name=LRParser.TokenText;*!
tkOverride 		= 'override'                    !*<procedure_attribute(proc_attribute.attr_override)> 	$$.name=LRParser.TokenText;*!
tkVirtual 		= 'virtual'                     !*<procedure_attribute(proc_attribute.attr_virtual)> 	$$.name=LRParser.TokenText;*!

tkAbsolute 		= 'absolute'                    !*<ident>*!
tkAssembler 		= 'assembler'                   !*<ident>*!
tkAutomated 		= 'automated'                   !*<ident>*!                                                                                         
tkDispid	 	= 'dispid'                      !*<ident>*!
tkExternal 		= 'external'                    !*<ident>*!  			
tkImplements 		= 'implements'                  !*<ident>*!
tkIndex 		= 'index'			!*<ident>*!
tkMessage 		= 'message'                     !*<ident>*!
tkName 			= 'name'                        !*<ident>*!
tkNodefault 		= 'nodefault'			!*<ident>*!
tkPrivate 		= 'private'                     !*<ident>*!   
tkProtected 		= 'protected'                   !*<ident>*!
tkPublic 		= 'public'                      !*<ident>*!
tkInternal 		= 'internal'                    !*<ident>*!
tkRead 			= 'read'			!*<ident>*!
tkResident 		= 'resident'                    !*<ident>*!
tkStored 		= 'stored'                      !*<ident>*!
tkWrite 		= 'write'                       !*<ident>*!
tkReadOnly 		= 'readonly'                    !*<ident>*!
tkWriteOnly		= 'writeonly'                   !*<ident>*!

tkParseModeExpression   = '<<expression>>'		
tkParseModeStatement = '<<statement>>'

! ======================================= Rules

<parse_goal> 				
        ::= <program_file> 		
         |  <unit_file> 
         |  <parts>		
!         |  <library_file> 		
!         |  <package_file> 		

<parts>
	::= tkParseModeExpression <expr> !*$$=$2;*!
		| tkParseModeStatement <stmt_or_expression> !*$$=$2;*!

<stmt_or_expression>
	::= <expr> <empty> !*3expression_as_statement<(expression)$1> parsertools.create_source_context($$,$1,$1);*!
	| <assignment>
	| <var_stmt>
	
!<error_recovery>
!        ::= tkInterface 
!         |  tkImplementation 
!         |  tkVar 
!         |  tkConst 
!         |  tkType 
!         |  tkResourceString 
!         |  tkObject 
!         |  tkFunction 
!         |  tkProcedure 
!         |  tkBegin 
!         |  tkEnd 
!         |  tkSemiColon 

<opt_head_compiler_directives>
 	::=
	 |  <head_compiler_directives>

<head_compiler_directives>
	::= <one_compiler_directive>				!*$$=null;*!
	 |  <head_compiler_directives> <one_compiler_directive> !*$$=null;*!

<one_compiler_directive>
	::= tkDirectiveName tkIdentifier       			!* {
									token_info t1 = new token_info();
									t1.text=((ident)$1).name;
					                                t1.source_context = ((ident)$1).source_context;
									token_info t2 = new token_info();
									t2.text=((ident)$2).name;
					                                t2.source_context = ((ident)$2).source_context;
									compiler_directive cd=new compiler_directive(t1,t2); 
									parsertools.create_source_context(cd,$1,$2); 
									CompilerDirectives.Add(cd); $$=null;
								}*!
	 |  tkDirectiveName tkStringLiteral       		!* {
									token_info t1 = new token_info();
									t1.text=((ident)$1).name;
					                                t1.source_context = ((ident)$1).source_context;
									token_info t2 = new token_info();
									t2.text=((string_const)$2).Value;
					                                t2.source_context = ((string_const)$2).source_context;
									compiler_directive cd=new compiler_directive(t1,t2); 
									parsertools.create_source_context(cd,$1,$2); 
									CompilerDirectives.Add(cd); $$=null;
								}*!

<program_file>
        ::= <program_heading> <opt_head_compiler_directives> <main_uses_clause> <using_clause> <program_block> <opt_tk_point> !*3program_module<$1 as program_name,(uses_list)$3,(block)$5,$4 as using_list>
									 $$.Language = LanguageId.PascalABCNET;
									 parsertools.create_source_context($$,parsertools.sc_not_null($1,$3,$4,$5),$5);
									 if ($6 == null && $5 != null)
									 {
										file_position fp = ($5 as syntax_tree_node).source_context.end_position;
										syntax_tree_node err_stn = (syntax_tree_node)$5;
										if (($5 is block) && ($5 as block).program_code != null && ($5 as block).program_code.subnodes != null && ($5 as block).program_code.subnodes.Count > 0)
										err_stn = ($5 as block).program_code.subnodes[($5 as block).program_code.subnodes.Count-1];
										errors.Add(new Errors.PABCNETUnexpectedToken(current_file_name, StringResources.Get("TKPOINT"),new SourceContext(fp.line_num, fp.column_num+1, fp.line_num, fp.column_num+1, 0, 0),err_stn));
									 }
									 *!
<opt_tk_point>
		::= tkPoint
		| tkSemiColon !*$$=null;*!
		| tkColon !*$$=null;*!
		| zkComma !*$$=null;*!
		| tkDotDot !*$$=null;*!
		|
		
<program_heading> 			
        ::= 
         |  tkProgram <program_name> <program_heading_2> 	!*3program_name<(ident)$2> parsertools.create_source_context($$,$1,$2);*!

<program_heading_2>
        ::= tkSemiColon 
         |  tkRoundOpen <program_param_list> tkRoundClose tkSemiColon !*$$=null;*!

<program_name>
        ::= <identifier> 			

<program_param_list>
        ::= <program_param> <empty> !*$$=null;*! 
         |  <program_param_list> tkComma <program_param> !*$$=null;*! 

<program_param>
        ::= <identifier> 

<program_block>
        ::= <program_decl_sect_list> <compound_stmt>  	!*3block<null,$2 as statement_list>
							if ($1!=null) {
								$$.defs=$1 as declarations;
								parsertools.create_source_context($$,$1,$2);
							}else	
								parsertools.create_source_context($$,$2,$2);
								//tasha 16.04.2010 
                            				add_lambda_to_program_block(_block);
							*!

<program_decl_sect_list>
        ::= <impl_decl_sect_list> 

<uses_clause>
	::= <main_uses_clause>
!        ::= 
!         |  tkUses <used_units_list> tkSemiColon 
!
!<used_units_list>
!        ::= <used_units_list> tkComma <used_unit_name> 
!         |  <used_unit_name>                           
!
!                                                       
!<used_unit_name>                                       
!        ::= tkIdentifier                               

<using_clause>
        ::= 
         |  <using_list>

<using_list>
	::= <using_one> <empty>                                 !*3using_list<>
								parsertools.create_source_context($$,$1,$1);
								$$.namespaces.Add((unit_or_namespace)$1);*!
	 |  <using_list> <using_one>                            !*1using_list<>$1;
								parsertools.create_source_context($$,$$,$2);
								$$.namespaces.Add((unit_or_namespace)$2);*!

<using_one>
	::=tkUsing <ident_or_keyword_pointseparator_list> tkSemiColon !*3unit_or_namespace<(ident_list)$2> parsertools.create_source_context($$,$1,$3);*!


<ident_or_keyword_pointseparator_list>
        ::= <identifier_or_keyword> <empty>                            		!*6ident_list<idents>ident*!
         |  <ident_or_keyword_pointseparator_list> tkPoint <identifier_or_keyword>  !*7ident_list<idents>ident*!   

<main_uses_clause>
        ::= 
         |  tkUses <main_used_units_list> tkSemiColon          	!* parsertools.create_source_context($2,$1,$3);$$=$2;*!

<main_used_units_list>
        ::= <main_used_units_list> tkComma <main_used_unit_name> !*1uses_list<>$1;
								$$.units.Add((unit_or_namespace)$3);
								*!
         |  <main_used_unit_name> <empty>                              !*3uses_list<>
								$$.units.Add((unit_or_namespace)$1);
								*!

<main_used_unit_name>
        ::= <ident_or_keyword_pointseparator_list> <empty>      !*0unit_or_namespace<(ident_list)$1>*!
         |  <ident_or_keyword_pointseparator_list> tkIn tkStringLiteral !*0uses_unit_in<>
								$$.name=(ident_list)$1;
								$$.in_file=(string_const)$3;
								*!

<library_file>
        ::= <library_heading> <main_uses_clause> <library_block> tkPoint 

<library_heading>
        ::= tkLibrary <identifier> tkSemiColon 

<library_block>
        ::= <library_impl_decl_sect_list> <compound_stmt> 

<library_impl_decl_sect_list>
        ::= 
         |  <library_impl_decl_sect_list> <library_impl_decl_sect> 

<library_impl_decl_sect>
        ::= <label_decl_sect> 
         |  <const_decl_sect> 
         |  <res_str_decl_sect> 
         |  <type_decl_sect> 
         |  <var_decl_sect> 
         |  <proc_decl> 
         |  <func_decl> 
         |  <constructor_decl> 
         |  <destructor_decl> 
         |  <export_clause> 

<export_clause>
        ::= tkExports <exports_list> tkSemiColon 

<exports_list>
        ::= <exports_entry> 
         |  <exports_list> tkComma <exports_entry> 

<exports_entry>
        ::= <identifier> <exports_index> <exports_name> <exports_resident> 

<exports_index>
        ::= 
         |  tkIndex <integer_const> 

<exports_name>
        ::= 
         |  tkName <identifier> 
         |  tkName <literal> 

<exports_resident>
        ::= 
         |  tkResident 

<unit_file>
        ::= <unit_heading> <interface_part> <implementation_part> <initialization_part> tkPoint !*3unit_module<(unit_name)$1,(interface_node)$2,(implementation_node)$3,((initfinal_part)$4).initialization_sect,((initfinal_part)$4).finalization_sect>
								$$.Language = LanguageId.PascalABCNET;                               
								parsertools.create_source_context($$,$1,$5);
								*!
        |   <unit_heading> <abc_interface_part> <initialization_part> tkPoint !*3unit_module<(unit_name)$1,(interface_node)$2,null,((initfinal_part)$3).initialization_sect,((initfinal_part)$3).finalization_sect>
								$$.Language = LanguageId.PascalABCNET;
                                                                parsertools.create_source_context($$,$1,$4);
								*!

<unit_heading>
        ::= <unit_key_word> <unit_name> tkSemiColon <opt_head_compiler_directives> !*3unit_name<(ident)$2,UnitHeaderKeyword.Unit> 
								if(((ident)$1).name.ToLower()=="library")
									$$.HeaderKeyword=UnitHeaderKeyword.Library;
								parsertools.create_source_context($$,$1,$3);*!

<unit_key_word>
	::= tkUnit
	 |  tkLibrary

<unit_name>
        ::= <identifier> 

<interface_part>
        ::= tkInterface <uses_clause> <using_clause> <int_decl_sect_list>  !*3interface_node<> 
								$$.uses_modules=$2 as uses_list;
								$$.using_namespaces=$3 as using_list;
								$$.interface_definitions=$4 as declarations;
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3,$2,$1));
								*!

<implementation_part>
        ::= tkImplementation <uses_clause> <using_clause> <impl_decl_sect_list> !*3implementation_node<>
								$$.uses_modules=$2 as uses_list;
								$$.using_namespaces=$3 as using_list;
								$$.implementation_definitions=$4 as declarations;
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3,$2,$1));
								*!
<abc_interface_part>
        ::=<uses_clause> <using_clause> <impl_decl_sect_list> 	!*3interface_node<>
								$$.uses_modules=$1 as uses_list;
								$$.using_namespaces=$2 as using_list;
								$$.interface_definitions=$3 as declarations;
								object lt=parsertools.sc_not_null($1,$2,$3);							
								object rt=parsertools.sc_not_null($3,$2,$1);							
								if (lt!=null)parsertools.create_source_context($$,lt,rt);
								*!

<initialization_part>                                           
        ::= tkEnd                                               !*3initfinal_part<>*!
         |  tkInitialization <stmt_list> tkEnd                  !*3initfinal_part<(statement_list)$2,null>
								((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
								((statement_list)$2).right_logical_bracket=(syntax_tree_node)$3;
								*!
         |  tkInitialization <stmt_list> tkFinalization <stmt_list> tkEnd !*3initfinal_part<(statement_list)$2,(statement_list)$4>
								((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
								((statement_list)$4).left_logical_bracket=(syntax_tree_node)$3;
								((statement_list)$4).right_logical_bracket=(syntax_tree_node)$5;
								*!
         |  tkBegin <stmt_list> tkEnd                           !*3initfinal_part<(statement_list)$2,null>
								((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
								((statement_list)$2).right_logical_bracket=(syntax_tree_node)$3;
								*!

<package_file>
        ::= tkPackage <package_name> tkSemiColon <requires_clause> <contains_clause> tkEnd tkPoint 

<package_name>
        ::= <identifier> 

<requires_clause>
        ::= 
         |  tkRequires 
         |  tkRequires <main_used_units_list> tkSemiColon 

<contains_clause>
        ::= 
         |  tkContains 
         |  tkContains <main_used_units_list> tkSemiColon 

<int_decl_sect_list>
	::= <int_decl_sect_list1> <empty>			!*if (((declarations)$1).defs.Count>0) return $1; return null;*!
<int_decl_sect_list1>
        ::= <empty> <empty>                                     !*3declarations<>*!
         |  <int_decl_sect_list1> <int_decl_sect>       !*1declarations<>$1;
							$$.defs.Add((declaration)$2);
							parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),$2);
							*!

<impl_decl_sect_list>
	::=<impl_decl_sect_list1> <empty>                      !*if (((declarations)$1).defs.Count>0) return $1; return null;*!
<impl_decl_sect_list1>
        ::= <empty> <empty>      			      	!*3declarations<>*!
         |  <impl_decl_sect_list1> <impl_decl_sect>  	!*1declarations<>$1;
							$$.defs.Add((declaration)$2);
							parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),$2);
							*!
<abc_decl_sect_list>
	::=<abc_decl_sect_list1> <empty>	                !*if (((declarations)$1).defs.Count>0) return $1; return null;*!
<abc_decl_sect_list1>
        ::= <empty> <empty>      			      	!*3declarations<>*!
         |  <abc_decl_sect_list1> <abc_decl_sect>  	!*1declarations<>$1;
							$$.defs.Add((declaration)$2);
							parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),$2);
							*!
<int_decl_sect>
        ::= <const_decl_sect> 
         |  <res_str_decl_sect> 
         |  <type_decl_sect> 
         |  <var_decl_sect> 
         |  <int_proc_heading> 
         |  <int_func_heading> 

<impl_decl_sect>
        ::= <label_decl_sect> 
         |  <const_decl_sect> 
         |  <res_str_decl_sect> 
         |  <type_decl_sect>                            
         |  <var_decl_sect>  				
         |  <proc_decl_with_attr>                              
         |  <func_decl_with_attr>
         |  <constructor_decl_with_attr>
         |  <destructor_decl_with_attr>

<proc_decl_with_attr>
	::= <opt_attribute_declarations> <proc_decl> !*2procedure_definition<> $$=($2 as procedure_definition); 
				if ($$.proc_header != null)
				$$.proc_header.attributes = $1 as attribute_list;
			*!
			
<func_decl_with_attr>
	::= <opt_attribute_declarations> <func_decl> !*2procedure_definition<> $$=($2 as procedure_definition); 
				if ($$.proc_header != null)
				$$.proc_header.attributes = $1 as attribute_list;
			*!
			
<constructor_decl_with_attr>
	::= <opt_attribute_declarations> <constructor_decl> !*2procedure_definition<> $$=($2 as procedure_definition); 
				if ($$.proc_header != null)
				$$.proc_header.attributes = $1 as attribute_list;
			*!

<destructor_decl_with_attr>
	::= <opt_attribute_declarations> <destructor_decl> !*2procedure_definition<> $$=($2 as procedure_definition); 
				if ($$.proc_header != null)
				$$.proc_header.attributes = $1 as attribute_list;
			*!
			
<abc_decl_sect>
        ::= <label_decl_sect> 
         |  <const_decl_sect> 
         |  <res_str_decl_sect> 
         |  <type_decl_sect>                            
         |  <var_decl_sect>  				

<int_proc_heading>
        ::= <opt_attribute_declarations> <proc_heading> !*2declaration<> $$=($2 as declaration); 
				$$.attributes = $1 as attribute_list;
			*!
!         |  <proc_heading> <inline_directr> tkSemiColon 
         | <opt_attribute_declarations> <proc_heading> tkForward tkSemiColon 	!*2procedure_header<> $$=($2 as procedure_header);
							if ($$.proc_attributes==null) $$.proc_attributes=new procedure_attributes_list();
							$$.proc_attributes.proc_attributes.Add((procedure_attribute)$3);
							$$.attributes = $1 as attribute_list;
							parsertools.create_source_context($$.proc_attributes,parsertools.sc_not_null($$.proc_attributes,$3),$3);
							parsertools.create_source_context($$,$2,$3);*!
!         |  <proc_heading> <fp_directives> 

<int_func_heading>
        ::= <opt_attribute_declarations> <func_heading> !*2declaration<> $$=($2 as declaration); 
				$$.attributes = $1 as attribute_list;
			*!
!         |  <func_heading> <inline_directr> tkSemiColon 
         |  <opt_attribute_declarations> <func_heading> tkForward tkSemiColon        !*2procedure_header<> $$=($2 as procedure_header);
							if ($$.proc_attributes==null) $$.proc_attributes=new procedure_attributes_list();
							$$.proc_attributes.proc_attributes.Add((procedure_attribute)$3);
							$$.attributes = $1 as attribute_list;
							parsertools.create_source_context($$.proc_attributes,parsertools.sc_not_null($$.proc_attributes,$3),$3);
							parsertools.create_source_context($$,$2,$3);*!
!         |  <func_heading> <fp_directives> 

<label_decl_sect>
        ::= tkLabel <label_list> tkSemiColon            !*3label_definitions<(ident_list)$2>
							parsertools.create_source_context($$,$1,$3);*!

<label_list>
        ::= <label_name> <empty>                               !*6ident_list<idents>ident*!
         |  <label_list> tkComma <label_name>           !*7ident_list<idents>ident*!

<label_name>
        ::= tkInteger <empty>                           !*3ident<>
								if($1 is int32_const)
									$$.name = ((int32_const)$1).val.ToString();
								else
								if($1 is int64_const)
									$$.name = ((int64_const)$1).val.ToString();
								else
									$$.name = ((uint64_const)$1).val.ToString();
								parsertools.assign_source_context($$,$1);*!
         |  tkFloat   <empty>                         	!*3ident<((double_const)$1).val.ToString()> parsertools.assign_source_context($$,$1);*!
         |  <identifier> 

<const_decl_sect>
        ::= tkConst <const_decl>                        !*3consts_definitions_list<>
							$$.const_defs.Add((const_definition)$2);
							parsertools.create_source_context($$,$1,$2);*!
         |  <const_decl_sect> <const_decl>        	!*1consts_definitions_list<>$1;
							$$.const_defs.Add((const_definition)$2);
							parsertools.create_source_context($$,$$,$2);*!

<res_str_decl_sect>
        ::= tkResourceString <const_decl> 
         |  <res_str_decl_sect> <const_decl> 

<type_decl_sect>
        ::= tkType <type_decl>                          !*3type_declarations<>
                                                ///////////////tasha 28.04.2010
            					pascalABC_type_declarations.Add((type_declaration)LRParser.GetReductionSyntaxNode(1));
            					///////////////////////////////
							$$.types_decl.Add((type_declaration)$2);
							parsertools.create_source_context($$,$1,$2);*!
         |  <type_decl_sect> <type_decl>        	!*1type_declarations<>$1;
							$$.types_decl.Add((type_declaration)$2);
							parsertools.create_source_context($$,$$,$2);*!

<var_decl_sect>
        ::= tkVar <var_decl>           			!*3variable_definitions<>
									///////////////tasha 28.04.2010
            pascalABC_var_statements.Add((var_def_statement)LRParser.GetReductionSyntaxNode(1));
            ///////////////////////////////
							$$.var_definitions.Add((var_def_statement)$2);
							parsertools.create_source_context($$,$1,$2);*!
		| tkEvent <var_decl> !*3variable_definitions<>
							$$.var_definitions.Add((var_def_statement)$2);
							($2 as var_def_statement).is_event = true;
							parsertools.create_source_context($$,$1,$2);
							*!
!         |  tkThreadvar <var_decl> 
         |  <var_decl_sect> <var_decl>           	!*1variable_definitions<>$1;
							$$.var_definitions.Add((var_def_statement)$2);
							parsertools.create_source_context($$,$$,$2);*!

<const_decl>
	::= <only_const_decl> tkSemiColon 		!*$$=$1;*!

<only_const_decl>
        ::= <const_name> tkEqual <init_const_expr> 	 	!*3simple_const_definition<>
								$$.const_name=(ident)$1;
								$$.const_value=(expression)$3;
								parsertools.create_source_context($$,$1,$3);*!						
         |  <const_name> tkColon <type_ref> tkEqual <typed_const> !*3typed_const_definition<>
								$$.const_name=(ident)$1;
								$$.const_type=(type_definition)$3;
								$$.const_value=(expression)$5;
								parsertools.create_source_context($$,$1,$5);*!						

<init_const_expr>
	::= <const_expr>
	 |  <array_const> 

<const_name>
        ::= <identifier> 

<const_expr>
        ::= <const_simple_expr> 
         |  <const_simple_expr> <const_relop> <const_simple_expr> 	!*0bin_expr<(expression)$1,(expression)$3,((op_type_node)$2).type>*!
         |  <question_constexpr>

<question_constexpr>
	::= <const_expr> tkQuestion <const_expr> tkColon <const_expr> 	!*3question_colon_expression<(expression)$1,(expression)$3,(expression)$5> parsertools.create_source_context($$,$1,$5);*!

<const_relop>
        ::= tkEqual 
         |  tkNotEqual 
         |  tkLower    
         |  tkGreater 
         |  tkLowerEqual 
         |  tkGreaterEqual 
         |  tkIn 

<const_simple_expr>
        ::= <const_term> 
         |  <const_simple_expr> <const_addop> <const_term> 		!*0bin_expr<(expression)$1,(expression)$3,((op_type_node)$2).type>*!

<const_addop>
        ::= tkPlus 
         |  tkMinus 
         |  tkOr 
         |  tkXor 

<as_is_constexpr>
	::= <const_term> <typecast_op> <simple_or_template_type_reference>    	!*0typecast_node<(addressed_value)$1,(type_definition)$3,(op_typecast)$2>
								if (!($1 is addressed_value)) 
									errors.Add(new Errors.bad_operand_type(current_file_name,((syntax_tree_node)$1).source_context,$$));								*!


<const_term>
        ::= <const_factor> 
	 |  <as_is_constexpr>
         |  <const_term> <const_mulop> <const_factor>                   !*0bin_expr<(expression)$1,(expression)$3,((op_type_node)$2).type>*!

<const_mulop>
        ::= tkStar 
         |  tkSlash 
         |  tkDiv 
         |  tkMod 
         |  tkShl 
         |  tkShr 
         |  tkAnd 

<const_factor>
        ::= <const_variable> 
         |  <const_set> 
         |  <unsigned_number> 
         |  <literal> 
         |  tkNil       <empty> 					!*3nil_const<> parsertools.create_source_context($$,$1,$1);*!
         |  tkAddressOf <const_factor>                          !*3get_address<(addressed_value)$2> parsertools.create_source_context($$,$1,$2);*!
         |  tkRoundOpen <const_expr> tkRoundClose               !* bracket_expr _expr = new bracket_expr((expression)$2); parsertools.create_source_context(_expr,$1,$3); $$=_expr;*!
         |  tkNot <const_factor> 				!*0un_expr<(expression)$2,((op_type_node)$1).type>*!
         |  <sign> <const_factor>                               !*0un_expr<(expression)$2,((op_type_node)$1).type>*!
         |  tkDeref <const_factor> 				!*3roof_dereference<> 
								$$.dereferencing_value=(addressed_value)$2;
								parsertools.create_source_context($$,$1,$2);*!

<const_set>
        ::= tkSquareOpen <const_elem_list> tkSquareClose 	!*3pascal_set_constant<$2 as expression_list>
								parsertools.create_source_context($$,$1,$3);*!

<sign>
        ::= tkPlus 
         |  tkMinus 

<const_variable>
        ::= <identifier> 
	 |  <sizeof_expr>
	 |  <typeof_expr>
         |  <const_variable> <const_variable_2>         !*if ($2 is dereference) {
							  ((dereference)$2).dereferencing_value=(addressed_value)$1;
							  parsertools.create_source_context($2,$1,$2);
							}
							if ($2 is dot_node) {
							  ((dot_node)$2).left=(addressed_value)$1;
							  parsertools.create_source_context($2,$1,((dot_node)$2).right);
							}
							$$=$2;
							*!

<const_variable_2>
        ::= tkPoint <identifier_or_keyword>                                !*3dot_node<null,(addressed_value)$2>*!
         |  tkDeref <empty>                                            !*3roof_dereference<> parsertools.assign_source_context($$,$1);*!
         |  tkRoundOpen <opt_const_func_expr_list> tkRoundClose 	!*3method_call<(expression_list)$2> parsertools.create_source_context($$,$1,$3);*!
         |  tkSquareOpen <const_elem_list> tkSquareClose      !*3indexer<(expression_list)$2> parsertools.create_source_context($$,$1,$3);*!

<opt_const_func_expr_list>
		::= <const_func_expr_list>
		|
		
<const_func_expr_list>
        ::= <const_expr> <empty>                               !*6expression_list<expressions>expression*!
         |  <const_func_expr_list> tkComma <const_expr>	!*7expression_list<expressions>expression*!

<const_elem_list>
        ::= <const_elem_list1> 				
         |  

<const_elem_list1>
        ::= <const_elem> <empty>                            	!*6expression_list<expressions>expression*!
         |  <const_elem_list1> tkComma <const_elem> 	!*7expression_list<expressions>expression*!

<const_elem>
        ::= <const_expr> 
         |  <const_expr> tkDotDot <const_expr> 		!*0diapason_expr<(expression)$1,(expression)$3>*!

<unsigned_number>
        ::= tkInteger 
         |  tkHex 
         |  tkFloat 

<typed_const>
        ::= <const_expr> 
         |  <array_const> 
         |  <record_const> 

<array_const>
        ::= tkRoundOpen <typed_const_list> tkRoundClose !*3array_const<(expression_list)$2>
							parsertools.create_source_context($$,$1,$3);*!
         |  tkRoundOpen <record_const> tkRoundClose     !*$$=$2;*!
         |  tkRoundOpen <array_const> tkRoundClose      !*$$=$2;*!

<typed_const_list>
        ::= 
         |  <typed_const_or_new> <empty>  !*3expression_list<>
							$$.expressions.Add((expression)$1);
							//$$.expressions.Add((expression)$3);
							//parsertools.create_source_context($$,$1,$3);
							*!
         |  <typed_const_list> tkComma <typed_const_or_new>    !*1expression_list<>$1;
							parsertools.create_source_context($$,$$,$3);
							if ($$ == null)
							{
								$$ = new expression_list();
								errors.Add(new Errors.PABCNETUnexpectedToken(current_file_name, StringResources.Get("TKIDENTIFIER"),((syntax_tree_node)$2).source_context,$$));
							}
							$$.expressions.Add((expression)$3);*!
<record_const>
        ::= tkRoundOpen <const_field_list> tkRoundClose !*parsertools.create_source_context($2,$1,$3);$$=$2;*!

<const_field_list>
	::= <const_field_list_1>                        
	 |  <const_field_list_1> tkSemiColon            !*$$=$1;*!
<const_field_list_1>
        ::= <const_field>    <empty>                           	!*6record_const<rec_consts>record_const_definition*!
         |  <const_field_list_1> tkSemiColon <const_field>	!*7record_const<rec_consts>record_const_definition*!

<const_field>
        ::= <const_field_name> tkColon <typed_const>  	!*0record_const_definition<(ident)$1,(expression)$3>*!

<const_field_name>
        ::= <identifier> 

<type_decl> 
		::= <opt_attribute_declarations> <simple_type_decl> !*2declaration<> $$=($2 as declaration); 
			$$.attributes = $1 as attribute_list;
		*!

<opt_attribute_declarations>
	::= <attribute_declarations> <empty> !* $$=$1; *!
	| <empty>
	
!<attribute_declarations>
!		::= <attribute_declaration> <empty> !*6attribute_list<attributes>simple_attribute_list*!
!		| <attribute_declarations> <attribute_declaration> !*7attribute_list<attributes>simple_attribute_list*!

<attribute_declarations>
	::= <attribute_declaration> <empty> !*3attribute_list<>
	 $$.attributes.Add((simple_attribute_list)$1);
	*!
	| <attribute_declarations> <attribute_declaration> !*1attribute_list<>$1;
							$$.attributes.Add((simple_attribute_list)$2);
							parsertools.create_source_context($$,$$,$2);*!
	
<attribute_declaration>
		::= tkSquareOpen <one_or_some_attribute> tkSquareClose !*$$=$2;*!

<one_or_some_attribute>
		::= <one_attribute> <empty> !*6simple_attribute_list<attributes>attribute*!
		| <one_or_some_attribute> tkComma <one_attribute> !*7simple_attribute_list<attributes>attribute*!
		
<one_attribute>
		::= <attribute_variable>
		| <identifier> tkColon <attribute_variable> !*2attribute<> $$=$3 as attribute;
			$$.qualifier = $1 as ident;
			*!
		
<simple_type_decl>
        ::= <type_decl_identifier> tkEqual <type_decl_type> tkSemiColon  !*0type_declaration<(ident)$1,(type_definition)$3>*!
         |  <template_identifier_with_equal> <type_decl_type> tkSemiColon  !*0type_declaration<(ident)$1,(type_definition)$2>*!

<type_decl_identifier>
	::= <identifier> 
	 |  <identifier> <template_arguments>			!*3template_type_name<(ident_list)$2>
								$$.name=((ident)$1).name;
								parsertools.create_source_context($$,$1,$2);
								*!
<template_identifier_with_equal>
	::= <identifier> tkLower <ident_list> tkGreaterEqual    !*3template_type_name<(ident_list)$3>
								$$.name=((ident)$1).name;
								parsertools.create_source_context($$,$1,$4);
								*!


<type_decl_type>
        ::= <type_ref>                                        
         |  tkType <type_ref>                                  !*parsertools.create_source_context($2,$1,$2);$$=$2;*!
         |  <object_type> 

<type_ref>
        ::= <simple_type> 
         |  <string_type> 
         |  <pointer_type> 
         |  <structured_type> 
         |  <procedural_type>
	 |  <template_type> 

<template_type>
	::= <simple_type_identifier> <template_type_params>     !*0template_type_reference<(named_type_reference)$1,(template_param_list)$2>*!

<template_type_params>
	::= tkLower <template_param_list> tkGreater             !*parsertools.create_source_context($2,$1,$3);$$=$2;*!

<template_param_list>
	::= <template_param> <empty>                          	!*6template_param_list<params_list>type_definition*!
	 |  <template_param_list> tkComma <template_param> 	!*7template_param_list<params_list>type_definition*!

<template_param>
	::= <simple_type_identifier>
	 |  <template_type>

<simple_type>
	::= <simple_type_identifier>
         |  <range_expr> tkDotDot <range_expr>  	!*0diapason<(expression)$1,(expression)$3>*!
         |  tkRoundOpen <enumeration_id_list> tkRoundClose !*3enum_type_definition<(enumerator_list)$2> parsertools.create_source_context($$,$1,$3);*!

<range_expr>
        ::= <range_term>                               	
         |  <range_expr> <const_addop> <range_term>     !*0bin_expr<$1 as expression,$3 as expression,((op_type_node)$2).type>*!

<range_term>
        ::= <range_factor> 
         |  <range_term> <const_mulop> <range_factor>   !*0bin_expr<$1 as expression,$3 as expression,((op_type_node)$2).type>*!

<range_factor>
        ::= <simple_type_identifier> <empty>                   !* if(((named_type_reference)$1).names.Count>0)
								$$=((named_type_reference)$1).names[0];
						 	   else
							        $$=null;
							*!
         |  <unsigned_number> 
         |  <sign> <range_factor> 			!*0un_expr<(expression)$2,((op_type_node)$1).type>*!
         |  <literal> 
!	 |  <identifier> tkRoundOpen <const_expr> tkRoundClose
         |  <range_factor> tkRoundOpen <const_elem_list> tkRoundClose !*3method_call<(expression_list)$3>
							$$.dereferencing_value=(addressed_value)$1;
							parsertools.create_source_context($$,$1,$4);
							*!
         |  tkRoundOpen <const_expr> tkRoundClose       !* $$=$2;*!

<range_methodname>                                                        
        ::= <identifier>                                        
         |  <identifier> tkPoint <identifier_or_keyword> !*0dot_node<(ident)$1,(ident)$3>*!

<simple_type_identifier>        
        ::= <identifier>        <empty>                   	!*6named_type_reference<names>ident*!
         |  <simple_type_identifier> tkPoint <identifier_or_keyword>	!*7named_type_reference<names>ident*!
!        ::= <identifier>                               !* {if ($1 is known_type_definition) return $1;
!							named_type_reference ntr=new named_type_reference(null,(ident)$1);
!							parsertools.create_source_context(ntr,$1,$1);
!							return ntr;}
!							*!
!         |  <unit_name> tkPoint <identifier>           !* {if ($3 is known_type_definition) {((known_type_definition)$3).unit_name=(ident)$1;return $3;}
!							named_type_reference ntr=new named_type_reference((ident)$1,(ident)$3);
!							parsertools.create_source_context(ntr,$1,$3);
!							return ntr;}
!							*!

<enumeration_id_list>
        ::= <enumeration_id> tkComma <enumeration_id>   !*3enumerator_list<>
                                                        $$.enumerators.Add((enumerator)$1);
                                                        $$.enumerators.Add((enumerator)$3);
							parsertools.create_source_context($$,$1,$3);
							*!   	
         |  <enumeration_id_list> tkComma <enumeration_id>!*1enumerator_list<>$1;
                                                        $$.enumerators.Add((enumerator)$3);
							parsertools.create_source_context($$,$$,$3);
							*! 
<enumeration_id>
        ::= <identifier> <empty>			!*0enumerator<$1 as ident,null>*!
		| <identifier> tkEqual <expr> !*0enumerator<$1 as ident,$3 as expression>*!
		
<pointer_type>
        ::= tkDeref <fptype> 				!*3ref_type<(type_definition)$2> parsertools.create_source_context($$,$1,$2);*!
                            
<structured_type>
        ::= <unpacked_structured_type> 
         |  tkPacked <unpacked_structured_type> 

<unpacked_structured_type>
        ::= <array_type> 
         |  <new_record_type> 
!         |  <record_type> 
         |  <set_type> 
         |  <file_type> 

<array_type>
        ::= tkArray tkSquareOpen <simple_type_list> tkSquareClose tkOf <type_ref> !*3array_type<(indexers_types)$3,(type_definition)$6>
										parsertools.create_source_context($3,$2,$4);
										parsertools.create_source_context($$,$1,$6);
										*!
	| <unsized_array_type>

<unsized_array_type>
	::= tkArray tkOf <type_ref>                                            	!*3array_type<null,(type_definition)$3>
										parsertools.create_source_context($$,$1,$3);
										*!
	
<simple_type_list>
        ::= <simple_type_or_empty>  <empty>                            	!*3indexers_types<>
							$$.indexers.Add((type_definition)$1);
							*!
         |  <simple_type_list> tkComma <simple_type_or_empty>    !*1indexers_types<>$1;
							$$.indexers.Add((type_definition)$3);
							*!

<simple_type_or_empty>
		::= <simple_type>
		|
		
<record_type>
        ::= tkRecord <field_list> tkEnd                 !*3record_type<(record_type_parts)$2,null> parsertools.create_source_context($$,$1,$3);*!
         |  tkRecord tkEnd                              !*3record_type<null,null> parsertools.create_source_context($$,$1,$2);*!

<field_list>                                            
        ::= <fixed_part>   <empty>                             !*3record_type_parts<(var_def_list)$1,null> parsertools.create_source_context($$,$1,$1);*!
         |  <variant_part> <empty>                             !*3record_type_parts<null,(variant_record_type)$1> parsertools.create_source_context($$,$1,$1);*!
         |  <fixed_part_2> tkSemiColon <variant_part>   !*0record_type_parts<(var_def_list)$1,(variant_record_type)$3>*!

<fixed_part>
        ::= <fixed_part_2>                            	
         |  <fixed_part_2> tkSemiColon                  !*$$=$1;*!
                                                                
<fixed_part_2>
        ::= <record_section>  <empty>                          !*6var_def_list<vars>var_def_statement*!
         |  <fixed_part_2> tkSemiColon <record_section> !*7var_def_list<vars>var_def_statement*!

<record_section>
        ::= <record_section_id_list> tkColon <type_ref> !*3var_def_statement<(ident_list)$1,(type_definition)$3,null,definition_attribute.None,false> 
							parsertools.create_source_context($$,$1,$3);
							*!
<record_section_id_list>
        ::= <record_section_id> <empty>                        	!*6ident_list<idents>ident*!
         |  <record_section_id_list> tkComma <record_section_id>!*7ident_list<idents>ident*!

<record_section_id>
        ::= <identifier> 

<variant_part>
        ::= tkCase <tag_field> tkOf <variant_list>      !*2variant_record_type<> $$=(variant_record_type)$2;
							$$.vars=$4 as variant_types;
							parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3));	
							*!

<tag_field>
        ::= <tag_field_name> <empty>                           !*3variant_record_type<(ident)$1,null,null>*!
         |  <tag_field_name> tkColon <tag_field_typename>!*3variant_record_type<(ident)$1,(type_definition)$3,null>*! 

<tag_field_name>
        ::= <identifier> 

<tag_field_typename>
        ::= <fptype> 

<variant_list>
        ::= <variant_list_2>                            
         |  <variant_list_2> tkSemiColon                !*$$=$1;*!

<variant_list_2>
        ::= <variant>        <empty>                           !*6variant_types<vars>variant_type*!
         |  <variant_list_2> tkSemiColon <variant>      !*7variant_types<vars>variant_type*!
<variant>
        ::= <case_tag_list> tkColon tkRoundOpen <variant_field_list> tkRoundClose !*3variant_type<(expression_list)$1,(record_type_parts)$4>
							parsertools.create_source_context($$,$1,$5);								
							*!

<variant_field_list>
        ::= 
         |  <field_list> 

<case_tag_list>
        ::= <const_expr_list>
!        ::= <const_expr> 
!         |  <case_tag_list> tkComma <const_expr> 

<const_expr_list>
        ::= <const_expr>     <empty>                           !*6expression_list<expressions>expression*!
         |  <const_expr_list> tkComma <const_expr> 	!*7expression_list<expressions>expression*!

<set_type>
        ::= tkSet tkOf <simple_type>    		!*3set_type_definition<(type_definition)$3>
							parsertools.create_source_context($$,$1,$3);*!

<file_type>
        ::= tkFile tkOf <type_ref> 			!*3file_type<(type_definition)$3> parsertools.create_source_context($$,$1,$3);*!
         |  tkFile              <empty>                	!*3file_type<> parsertools.assign_source_context($$,$1);*!

<string_type>
	::= tkIdentifier tkSquareOpen <const_expr> tkSquareClose  	!*3string_num_definition<(expression)$3,(ident)$1>
								parsertools.create_source_context($$,$1,$4);*!

<procedural_type>
        ::= <procedural_type_kind> 
!         |  <procedural_type_kind> <calling_conventions> 

<procedural_type_kind>
        ::= <procedural_type_decl>

<procedural_type_decl>
        ::= tkProcedure <fp_list> <maybe_error>		     	!*3procedure_header<(formal_parameters)$2,null,null,false,false,null,null> 
								object rt=$1;
								if ($2!=null) rt=$2;
								parsertools.create_source_context($$,$1,rt);
								if($3!=null)
									($3 as SyntaxError).bad_node=$$;
								*!
         |  tkFunction <fp_list> tkColon <fptype> 		!*3function_header<> 
								if ($2!=null) 
		                                                  $$.parameters=(formal_parameters)$2;
								if ($4!=null) 
								  $$.return_type=(type_definition)$4;
								$$.of_object=false;
								$$.class_keyword=false;
								parsertools.create_source_context($$,$1,$4);
								*!

<maybe_error>
	::= tkColon <fptype>					!* Errors.unexpected_return_value er=new Errors.unexpected_return_value(current_file_name,((syntax_tree_node)$2).source_context,null); errors.Add(er);$$=er;*!
	 |

<object_type>
        ::= <new_object_type> 
!         |  <old_object_type> 

!<old_object_type>
!        ::= tkObject <oot_successor> <oot_component_list> <oot_privat_list> tkEnd 

<oot_privat_list>
        ::= 
         |  tkPrivate <oot_component_list> 

<oot_component_list>
        ::= 
         |  <oot_field_list> 
         |  <oot_field_list> <oot_method_list> 
         |  <oot_method_list> 

<oot_successor>
        ::= tkRoundOpen <oot_typeidentifier> tkRoundClose 

<oot_typeidentifier>
        ::= <identifier> 

<oot_field_list>
        ::= <oot_field> 
         |  <oot_field_list> <oot_field> 

<oot_field>
        ::= <oot_id_list> tkColon <type_ref> tkSemiColon 

<oot_id_list>
        ::= <oot_field_identifier> 
         |  <oot_id_list> tkComma <oot_field_identifier> 

<oot_field_identifier>
        ::= <identifier> 

<oot_method_list>
        ::= <oot_method> 
         |  <oot_method_list> <oot_method> 

<oot_method>
        ::= <oot_method_head> 

<oot_method_head>
        ::= <proc_heading> 
         |  <func_heading> 
         |  <oot_constructor_head> 
         |  <oot_destructor_head> 

<oot_constructor_head>
        ::= tkConstructor <proc_name> <fp_list> <opt_meth_modificators> 

<oot_destructor_head>
        ::= tkDestructor <proc_name> <fp_list> <opt_meth_modificators>

<new_object_type>
        ::= <not_object_type> 
!         |  <not_class_reference_type> 

!<not_class_reference_type>
!        ::= tkClass tkOf <not_object_type_identifier> 

!<not_object_type_identifier>
!        ::= <identifier> 

<not_object_type>
        ::= <class_attributes> <class_or_interface_keyword> <opt_base_classes> <opt_where_section> <opt_not_component_list_seq_end> !*3class_definition<$3 as named_type_reference_list,$5 as class_body,class_keyword.Class,null,$4 as where_definition_list, class_attribute.None> 
									string kw=($2 as token_info).text.ToLower();
									if($1!=null)
										$$.attribute=(class_attribute)(($1 as token_taginfo).tag);
									if (kw=="record") 
										$$.keyword=class_keyword.Record;
									else
									if (kw=="interface") 
										$$.keyword=class_keyword.Interface;
									else
									if (kw=="i<>") 
										$$.keyword=class_keyword.TemplateInterface;
									else
									if (kw=="r<>") 
										$$.keyword=class_keyword.TemplateRecord;
									else
									if (kw=="c<>") 
										$$.keyword=class_keyword.TemplateClass;
									if ($$.body!=null && $$.body.class_def_blocks!=null && 
										$$.body.class_def_blocks.Count>0 && $$.body.class_def_blocks[0].access_mod==null)
									{
										if($$.keyword==class_keyword.Class)
		                        						$$.body.class_def_blocks[0].access_mod = new access_modifer_node(access_modifer.internal_modifer);
										else
											$$.body.class_def_blocks[0].access_mod = new access_modifer_node(access_modifer.none);
									}	
									parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),parsertools.sc_not_null($5,$4,$3,$2,$1));*!


<new_record_type> 
	::= <record_keyword> <opt_base_classes> <opt_where_section> <not_component_list_seq> tkEnd	!*3class_definition<$2 as named_type_reference_list,$4 as class_body,class_keyword.Record,null,$3 as where_definition_list, class_attribute.None> 
									if ($$.body!=null && $$.body.class_def_blocks!=null && 
										$$.body.class_def_blocks.Count>0 && $$.body.class_def_blocks[0].access_mod==null)
									{
		                        					$$.body.class_def_blocks[0].access_mod = new access_modifer_node(access_modifer.public_modifer);
									}	
									parsertools.create_source_context($$,$1,$5);*!

<class_attributes>
	::= tkFinal
	 |  

<class_or_interface_keyword>
	::= tkClass
	 |  tkInterface
	 |  tkTemplate                                  	!*1token_info<>$1;$$.text="c<>";*!
	 |  tkTemplate tkClass                                  !*1token_info<>$1;$$.text="c<>";parsertools.create_source_context($$,$1,$2);*!
         |  tkTemplate tkRecord					!*1token_info<>$1;$$.text="r<>";parsertools.create_source_context($$,$1,$2);*!
	 |  tkTemplate tkInterface                             	!*1token_info<>$1;$$.text="i<>";parsertools.create_source_context($$,$1,$2);*!

<record_keyword>
        ::= tkRecord

<opt_not_component_list_seq_end>
	::= 
	 |  <not_component_list_seq> tkEnd 			!*parsertools.create_source_context($1,parsertools.sc_not_null($1,$2),$2);$$=$1;*!

<opt_base_classes>
	::=
	 |  tkRoundOpen <base_classes_names_list> tkRoundClose	!*$$=$2;*!

<base_classes_names_list>
	::= <base_class_name> <empty>             		!*6named_type_reference_list<types>named_type_reference*!
	 |  <base_classes_names_list> tkComma <base_class_name> !*7named_type_reference_list<types>named_type_reference*!     	

<base_class_name>
	::= <simple_type_identifier>
	 |  <template_type>


<opt_template_arguments>
	::=
	 |  <template_arguments>

<template_arguments>
	::= tkLower <ident_list> tkGreater 			!*parsertools.create_source_context($2,$1,$3);$$=$2;*!

<opt_where_section>
	::=
	 |  <where_part_list>          

<where_part_list>
	::= <where_part> <empty>               !*3where_definition_list<>
				    		parsertools.create_source_context($$,$1,$1);
						$$.defs.Add((where_definition)$1);*!
	 |  <where_part_list> <where_part>     !*1where_definition_list<>$1;
						parsertools.create_source_context($$,$$,$2);
						$$.defs.Add((where_definition)$2);*!

<where_part>
	::= tkWhere <ident_list> tkColon <type_ref_and_secific_list> tkSemiColon !*3where_definition<(ident_list)$2,(type_definition_list)$4>
											parsertools.create_source_context($$,$1,$5);*!

<type_ref_and_secific_list>
	::= <type_ref_or_secific> <empty>				!*6type_definition_list<defs>type_definition*!
	 |  <type_ref_and_secific_list> tkComma <type_ref_or_secific>   !*7type_definition_list<defs>type_definition*!

<type_ref_or_secific>
	::= <type_ref>
	 |  tkClass			!*3declaration_specificator<DeclarationSpecificator.WhereDefClass, ($1 as token_info).text>
					parsertools.assign_source_context($$,$1);*!
	 |  tkRecord                    !*3declaration_specificator<DeclarationSpecificator.WhereDefValueType, ($1 as token_info).text>
					parsertools.assign_source_context($$,$1);*!
	 |  tkConstructor               !*3declaration_specificator<DeclarationSpecificator.WhereDefConstructor, ($1 as token_info).text>
					parsertools.assign_source_context($$,$1);*!

<record_component_list>
	::= <not_component_list> <empty>!*3class_body<>
					if ($1!=null) {
		                        access_modifer_node acn=new access_modifer_node(access_modifer.public_modifer);
					((class_members)$1).access_mod = acn;
					$$.class_def_blocks.Add((class_members)$1);
					parsertools.assign_source_context($$,$1);							
					}
					*!

<not_component_list_seq>
        ::= <not_component_list> <empty>    	!*3class_body<>
					if ($1!=null) {
					$$.class_def_blocks.Add((class_members)$1);
					parsertools.assign_source_context($$,$1);							
					}
					*!
         |  <not_component_list_seq> <ot_visibility_specifier> <not_component_list> !*1class_body<>$1;
					class_members cl=(class_members)$3;
					if (cl==null) 
					{	
						cl=new class_members();
						parsertools.create_source_context(cl,$2,$2);
					}
					cl.access_mod=(access_modifer_node)$2;
					$$.class_def_blocks.Add(cl);
					parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),parsertools.sc_not_null(cl,$2));							
					*!

<ot_visibility_specifier>
        ::= tkInternal 			!*3access_modifer_node<access_modifer.internal_modifer> parsertools.assign_source_context($$,$1);*!
         |  tkPublic                    !*3access_modifer_node<access_modifer.public_modifer> parsertools.assign_source_context($$,$1);*!
         |  tkProtected                 !*3access_modifer_node<access_modifer.protected_modifer> parsertools.assign_source_context($$,$1);*!
         |  tkPrivate                   !*3access_modifer_node<access_modifer.private_modifer> parsertools.assign_source_context($$,$1);*!



<not_object_type_identifier_list>                                                            
	::= <simple_type_identifier> <empty>                                          !*6named_type_reference_list<types>named_type_reference*!
	 |  <not_object_type_identifier_list> tkComma <simple_type_identifier> !*7named_type_reference_list<types>named_type_reference*!     	
!        ::= <identifier> 
!         |  <not_object_type_identifier_list> tkComma <identifier> 

<ident_list>
        ::= <identifier> <empty>                               !*6ident_list<idents>ident*!
         |  <ident_list> tkComma <identifier>    	!*7ident_list<idents>ident*!

<not_component_list>
        ::= <not_guid>                                  
         |  <not_guid> <not_component_list_1> <opt_semicolon>          !*$$=$2;*!
         |  <not_guid> <not_component_list_2>           !*$$=$2;*!
         |  <not_guid> <not_component_list_1> tkSemiColon <not_component_list_2> !*2class_members<> $$=(class_members)$2;
							for (int i=0;i<((class_members)$4).members.Count;i++)
								$$.members.Add(((class_members)$4).members[i]);
							parsertools.create_source_context($$,$2,$4);							
							*!
<opt_semicolon>
	::=
	 |  tkSemiColon

<not_guid>
        ::= 
!         |  tkSquareOpen <const_expr> tkSquareClose 

<not_component_list_1>
        ::= <filed_or_const_definition> <empty>                     !*3class_members<>
							$$.members.Add((declaration)$1);
							parsertools.assign_source_context($$,$1);							
							*!
         |  <not_component_list_1> tkSemiColon <filed_or_const_definition_or_am>!*1class_members<>$1;
							if($3 is declaration)
								$$.members.Add((declaration)$3);
							else
								($$.members[$$.members.Count-1] as var_def_statement).var_attr=definition_attribute.Static;
							parsertools.create_source_context($$,$1,$3);							
							*! 

<not_component_list_2>
        ::= <not_method_definition> <empty>                    !*3class_members<>
							$$.members.Add((declaration)$1);
							parsertools.assign_source_context($$,$1);							
							*!
         |  <not_property_definition> <empty>                  !*3class_members<>
							$$.members.Add((declaration)$1);
							parsertools.assign_source_context($$,$1);							
							*!
         |  <not_component_list_2> <not_method_definition>!*1class_members<>$1;
							$$.members.Add((declaration)$2);
							parsertools.create_source_context($$,$1,$2);							
							*! 
         |  <not_component_list_2> <not_property_definition>!*1class_members<>$1;
							$$.members.Add((declaration)$2);
							parsertools.create_source_context($$,$1,$2);							
							*! 

<filed_or_const_definition>
	::= <opt_attribute_declarations> <simple_filed_or_const_definition> !*2declaration<> $$=$2 as declaration;
			$$.attributes = $1 as attribute_list;
		*!
	
<simple_filed_or_const_definition>
	::= tkConst <only_const_decl> 			!* parsertools.create_source_context($2,$1,$2); $$=$2;*!
	  | <not_field_definition> 			
	  | tkClass <not_field_definition> 		!*1var_def_statement<>$2;
							$$.var_attr = definition_attribute.Static;
							parsertools.create_source_context($$,$1,$2);
							*!

<filed_or_const_definition_or_am>
	::= <filed_or_const_definition>
	  | <field_access_modifier>

<not_field_definition>
	 ::= <var_decl_part>
          |  tkEvent <var_name_list> tkColon <type_ref> !*3var_def_statement<(ident_list)$2,(type_definition)$4,null,definition_attribute.None,true>
							parsertools.create_source_context($$,$1,$4);
							*! 
!        ::= <not_field_identifier_list> tkColon <type_ref> <opt_not_field_definition_init_value>!*3var_def_statement<(ident_list)$1,(type_definition)$3,$4 as expression,definition_attribute.None,false> 
!							parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3));
!							*!

<field_access_modifier>
	::= tkStatic			

!<opt_not_field_definition_init_value>
!	::=
!	 |  tkEqual <var_init_value>			!*$$=$2;*!

!<not_field_identifier_list>
!        ::= <not_field_identifier>  <empty>                    		!*6ident_list<idents>ident*!
!         |  <not_field_identifier_list> tkComma <not_field_identifier>	!*7ident_list<idents>ident*!

!<not_field_identifier>
!        ::= <identifier> 

<not_method_definition>
        ::= <opt_attribute_declarations> <not_method_heading> !*2declaration<> $$=($2 as declaration);
			if ($$ != null)
			$$.attributes = $1 as attribute_list; 
		*!
	 |  <opt_attribute_declarations> <abc_method_decl> !*2procedure_definition<> $$=($2 as procedure_definition);
			if ($$ != null && $$.proc_header != null)
			$$.proc_header.attributes = $1 as attribute_list; 
	 *!

<abc_method_decl>
	::= <abc_proc_decl>
	 |  <abc_func_decl>
	 |  <abc_constructor_decl>
	 |  <abc_destructor_decl>

<not_method_heading>
        ::= tkClass <not_procfunc_heading> !* ((procedure_header)$2).class_keyword=true;$$=$2;*!
         |  <not_procfunc_heading>
         |  <not_constructor_heading> 
         |  <not_destructor_heading> 

<not_procfunc_heading>
	::= <not_procfunc_heading_variants> <empty> !* ((procedure_header)$1).name.explicit_interface_name=((procedure_header)$1).name.class_name; 
							((procedure_header)$1).name.class_name=null;
							$$=$1;*!

<not_procfunc_heading_variants>
	::= <proc_heading>	
         |  <func_heading> 

<optional_qualified_identifier>
       ::=  <qualified_identifier>
	 |  

<not_constructor_heading>
	::= <not_constructor_heading_object> 
	 |  tkClass <not_constructor_heading_object> !* ((procedure_header)$2).class_keyword=true;$$=$2;*!

<opt_proc_name>
	::= <proc_name>
	 |

<not_constructor_heading_object>
        ::= tkConstructor <opt_proc_name> <fp_list> <opt_meth_modificators> !*3constructor<> 
								object rt=$2;
								$$.name=$2 as method_name;
								if ($3!=null) {
								  rt=$3;
		                                                  $$.parameters=(formal_parameters)$3;
								}
								if ($4!=null) {
								  rt=$4;
								  if (((procedure_attributes_list)$4).proc_attributes.Count>0) 
									$$.proc_attributes=(procedure_attributes_list)$4;
								}
								parsertools.create_source_context($$,$1,rt);
								*!

<not_destructor_heading>
        ::= tkDestructor <opt_proc_name> <fp_list> <opt_meth_modificators> !*3destructor<> 
								object rt=$2;
								$$.name=$2 as method_name;
								if ($3!=null) {
								  rt=$3;
		                                                  $$.parameters=(formal_parameters)$3;
								}
								if ($4!=null) {
								  rt=$4;
								  if (((procedure_attributes_list)$4).proc_attributes.Count>0) 
									$$.proc_attributes=(procedure_attributes_list)$4;
								}
								parsertools.create_source_context($$,$1,rt);
								*!

<qualified_identifier>
        ::= <identifier>               <empty>                         !*0method_name<null,(ident)$1,null>*!
         |  <visibility_specifier>     <empty>                         !*0method_name<null,(ident)$1,null>*!
         |  <qualified_identifier> tkPoint <identifier>                    !*{
								method_name mn=(method_name)$1;
								mn.class_name=mn.meth_name;
								mn.meth_name=(ident)$3;
								parsertools.create_source_context($1,$1,$3);
								$$=$1;
								}*!
         |  <qualified_identifier> tkPoint <visibility_specifier>          !*{
								method_name mn=(method_name)$1;
								mn.class_name=mn.meth_name;
								mn.meth_name=(ident)$3;
								parsertools.create_source_context($1,$1,$3);
								$$=$1;
								}*!

<not_property_definition>
	::= <opt_attribute_declarations> <simple_not_property_definition> !*2declaration<> $$=$2 as declaration;
			$$.attributes = $1 as attribute_list;
		*!
	
<simple_not_property_definition>
	::= <not_simple_property_definition>
	 |  tkClass <not_simple_property_definition> 	!*1simple_property<>$2; 
							$$.attr=definition_attribute.Static;
						     	parsertools.create_source_context($$,$1,$2);
							*!
<not_simple_property_definition>
        ::= tkProperty <qualified_identifier> <not_property_interface> <not_property_specifiers> tkSemiColon <not_array_defaultproperty> !*3simple_property<>
								$$.property_name=((method_name)$2).meth_name;
								if ($3!=null){
									$$.parameter_list=((property_interface)$3).parameter_list;
									$$.property_type=((property_interface)$3).property_type;
									$$.index_expression=((property_interface)$3).index_expression;
								}
								if ($4!=null) $$.accessors=(property_accessors)$4;
								if ($6!=null) $$.array_default=(property_array_default)$6;
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($6,$5,$4,$3,$2,$1));
								*!

<not_array_defaultproperty>
        ::= 
         |  tkDefault tkSemiColon    				!*3property_array_default<> parsertools.create_source_context($$,$1,$2);*!

<not_property_interface>
        ::= 
         |  <not_property_parameter_list> tkColon <fptype> <not_property_interface_index> !*3property_interface<>
								$$.parameter_list=(property_parameter_list)$1;
								$$.property_type=(type_definition)$3;
								$$.index_expression=(expression)$4;
								parsertools.create_source_context($$,parsertools.sc_not_null($1,$2,$3,$4),parsertools.sc_not_null($4,$3,$2,$1));
								*!

<not_property_interface_index>
        ::= 
         |  tkIndex <expr> 					!*$$=$2;*!

<not_property_parameter_list>
        ::= 
         |  tkSquareOpen <not_parameter_decl_list> tkSquareClose!*$$=$2;*!

<not_parameter_decl_list>
        ::= <not_parameter_decl>        <empty>                        	!*6property_parameter_list<parameters>property_parameter*!
         |  <not_parameter_decl_list> tkSemiColon <not_parameter_decl>	!*7property_parameter_list<parameters>property_parameter*!

<not_parameter_decl>                                            
        ::= <not_parameter_name_list> tkColon <fptype>          !*0property_parameter<(ident_list)$1,(type_definition)$3>*!
         |  tkConst <not_parameter_name_list> tkColon <fptype> 
         |  tkVar <not_parameter_name_list> tkColon <fptype> 
         |  tkOut <not_parameter_name_list> tkColon <fptype> 

<not_parameter_name_list>
	::= <ident_list>
!        ::= <not_parameter_name> 
!         |  <not_parameter_name_list> tkComma <not_parameter_name> 

!<not_parameter_name>
!        ::= <identifier> 


<opt_identifier>
	::= <identifier>
	 | 

<not_property_specifiers>
        ::= 
         |  tkReadOnly <not_property_specifiers> 
         |  tkWriteOnly <not_property_specifiers> 
!         |  tkDispid <const_expr> <not_property_specifiers> 
         |  tkDefault <const_expr> <not_property_specifiers> 
!         |  tkNodefault <not_property_specifiers> 
!         |  tkStored <const_expr> <not_property_specifiers> 
!         |  tkImplements <not_object_type_identifier_list> <not_property_specifiers> 
!         |  tkRead <expr> <not_property_specifiers> ???
!         |  tkWrite <expr> <not_property_specifiers>??? 
         |  tkRead <opt_identifier> <not_property_specifiers>  	!*2property_accessors<> 
								property_accessors _pa=$3 as property_accessors;
							        if (_pa==null) {
								_pa=new property_accessors();parsertools.create_source_context(_pa,$1,parsertools.sc_not_null($2,$1));
								}
								$$=_pa;
								if($2!=null && ((ident)$2).name.ToLower()=="write")
								{
								$$.read_accessor=new read_accessor_name(null);
								$$.write_accessor=new write_accessor_name(null);
								parsertools.create_source_context($$.read_accessor,$1,$1);
								parsertools.create_source_context($$.write_accessor,$2,$2);
								parsertools.create_source_context($$,$1,$2);
								}
								else
								{
								$$.read_accessor=new read_accessor_name((ident)$2);								
								parsertools.create_source_context($$.read_accessor,$1,parsertools.sc_not_null($2,$1));
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($3,$2,$1));
								}
								*!
         |  tkWrite <opt_identifier> <not_property_specifiers>      !*2property_accessors<> 
								property_accessors _pa=$3 as property_accessors;
							        if (_pa==null) {
								_pa=new property_accessors();parsertools.create_source_context(_pa,$1,parsertools.sc_not_null($2,$1));
								}
								$$=_pa;
								$$.write_accessor=new write_accessor_name((ident)$2);
								parsertools.create_source_context($$.write_accessor,$1,parsertools.sc_not_null($2,$1));
								parsertools.create_source_context($$,$1,_pa);
								*!

<var_decl>
	::= <var_decl_part> tkSemiColon				!*$$=$1;*!

<var_decl_part>
        ::= <var_decl_part_normal>
	 |  <var_decl_part_assign>
         |  <var_name_list> tkColon <type_ref> tkAssign <var_init_value_typed> !*0var_def_statement<(ident_list)$1,(type_definition)$3,(expression)$5,definition_attribute.None,false>*! 

<var_decl_part_in_stmt>
	::= <var_decl_part>

<var_decl_part_assign>
	::= <var_name_list> tkAssign <var_init_value> !*0var_def_statement<(ident_list)$1,null,(expression)$3,definition_attribute.None,false>*! 

<var_decl_part_normal>
        ::= <var_name_list> tkColon <type_ref> !*0var_def_statement<(ident_list)$1,(type_definition)$3,null,definition_attribute.None,false>*! 

<var_init_value>
        ::= <expr>

<var_init_value_typed>
        ::= <typed_const_or_new>

<typed_const_or_new>
        ::= <typed_const> 
	 |  <new_expr>
	 |  <default_expr>

<var_name_list>
        ::= <var_name>                  <empty>             		!*0ident_list<>
								$$.idents.Add((ident)$1);*!
         |  <var_name_list> tkComma <var_name>                  !*1ident_list<>$1;
								$$.idents.Add((ident)$3);
								parsertools.create_source_context($$,$$,$3);*!

<var_name>
        ::= <identifier> 

!<absolute_clause>
!        ::= 
!        |  tkAbsolute tkInteger tkColon tkInteger 
!        |  tkAbsolute tkHex tkColon tkHex 
!        |  tkAbsolute <declared_var_name> 

<declared_var_name>
        ::= <identifier> 

<constructor_decl>
        ::= <not_constructor_heading> <not_constructor_block_decl>	!*9procedure_definition<(procedure_header)$1,null>*! 

<abc_constructor_decl>
        ::= <not_constructor_heading> <abc_block>			!*9procedure_definition<(procedure_header)$1,null>*! 

<destructor_decl>
        ::= <not_destructor_heading> <not_constructor_block_decl>	!*9procedure_definition<(procedure_header)$1,null>*! 

<abc_destructor_decl>
        ::= <not_destructor_heading> <abc_block>			!*9procedure_definition<(procedure_header)$1,null>*! 

<not_constructor_block_decl>
        ::= <block> 
         |  <external_directr> 
         |  <asm_block> 

<proc_decl>
	::= <proc_decl_noclass>
	 |  tkClass <proc_decl_noclass>				!* (($2 as procedure_definition).proc_header as procedure_header).class_keyword=true;$$=$2;*!

<proc_decl_noclass>
        ::= <proc_heading> <proc_block>                      	!*{
			procedure_definition _procedure_definition=new procedure_definition((procedure_header)LRParser.GetReductionSyntaxNode(0),null);
			object rt=LRParser.GetReductionSyntaxNode(0);
			if(LRParser.GetReductionSyntaxNode(1)!=null) {
				rt=LRParser.GetReductionSyntaxNode(1);
                if (LRParser.GetReductionSyntaxNode(1) is proc_block)
                {
                    add_lambda(LRParser.GetReductionSyntaxNode(1), _procedure_definition);//tasha 16.04.2010
                }
				if(LRParser.GetReductionSyntaxNode(1) is procedure_attribute) {
					procedure_header ph=_procedure_definition.proc_header;
					if(ph.proc_attributes==null) {
						ph.proc_attributes=new procedure_attributes_list();
						parsertools.assign_source_context(ph.proc_attributes,LRParser.GetReductionSyntaxNode(1));
					}
					ph.proc_attributes.proc_attributes.Add((procedure_attribute)LRParser.GetReductionSyntaxNode(1));
					parsertools.create_source_context(ph.proc_attributes,ph.proc_attributes,LRParser.GetReductionSyntaxNode(1));
				}
			}	
			parsertools.create_source_context(_procedure_definition,LRParser.GetReductionSyntaxNode(0),rt);
			
			return _procedure_definition;
		}*!

<abc_proc_decl>
	::= <abc_proc_decl_noclass>
	 |  tkClass <abc_proc_decl_noclass>			!* (($2 as procedure_definition).proc_header as procedure_header).class_keyword=true;$$=$2;*!

<abc_proc_decl_noclass>
        ::= <proc_heading> <abc_proc_block>                    	!*{procedure_definition _procedure_definition=new procedure_definition((procedure_header)LRParser.GetReductionSyntaxNode(0),null);
			object rt=LRParser.GetReductionSyntaxNode(0);
			if(LRParser.GetReductionSyntaxNode(1)!=null) {
				rt=LRParser.GetReductionSyntaxNode(1);
                if (LRParser.GetReductionSyntaxNode(1) is proc_block)
                {
                    add_lambda(LRParser.GetReductionSyntaxNode(1), _procedure_definition);//tasha 16.04.2010
                }
				if(LRParser.GetReductionSyntaxNode(1) is procedure_attribute) {
					procedure_header ph=_procedure_definition.proc_header;
					if(ph.proc_attributes==null) {
						ph.proc_attributes=new procedure_attributes_list();
						parsertools.assign_source_context(ph.proc_attributes,LRParser.GetReductionSyntaxNode(1));
					}
					ph.proc_attributes.proc_attributes.Add((procedure_attribute)LRParser.GetReductionSyntaxNode(1));
					parsertools.create_source_context(ph.proc_attributes,ph.proc_attributes,LRParser.GetReductionSyntaxNode(1));
				}
			}	
			parsertools.create_source_context(_procedure_definition,LRParser.GetReductionSyntaxNode(0),rt);
			
			return _procedure_definition;}*!

<func_decl>
	::= <func_decl_noclass>
	 |  tkClass <func_decl_noclass>				!* (($2 as procedure_definition).proc_header as procedure_header).class_keyword=true;$$=$2;*!

<func_decl_noclass>
        ::= <func_heading> <func_block>                         !*{
			procedure_definition _procedure_definition=new procedure_definition((function_header)LRParser.GetReductionSyntaxNode(0),null);
			object rt=LRParser.GetReductionSyntaxNode(0);
			if(LRParser.GetReductionSyntaxNode(1)!=null) {
				rt=LRParser.GetReductionSyntaxNode(1);
                if (LRParser.GetReductionSyntaxNode(1) is proc_block)
                {
                    add_lambda(LRParser.GetReductionSyntaxNode(1), _procedure_definition);//tasha 16.04.2010
                }
				if(LRParser.GetReductionSyntaxNode(1) is procedure_attribute) {
					procedure_header ph=_procedure_definition.proc_header;
					if(ph.proc_attributes==null) {
						ph.proc_attributes=new procedure_attributes_list();
						parsertools.assign_source_context(ph.proc_attributes,LRParser.GetReductionSyntaxNode(1));
					}
					ph.proc_attributes.proc_attributes.Add((procedure_attribute)LRParser.GetReductionSyntaxNode(1));
					parsertools.create_source_context(ph.proc_attributes,ph.proc_attributes,LRParser.GetReductionSyntaxNode(1));
				}
			}	
			parsertools.create_source_context(_procedure_definition,LRParser.GetReductionSyntaxNode(0),rt);
			
			return _procedure_definition;}*!

<abc_func_decl>
	::= <abc_func_decl_noclass>
	 |  tkClass <abc_func_decl_noclass>			!* (($2 as procedure_definition).proc_header as procedure_header).class_keyword=true;$$=$2;*!

<abc_func_decl_noclass>
        ::= <func_heading> <abc_proc_block>                     !*{
			procedure_definition _procedure_definition=new procedure_definition((function_header)LRParser.GetReductionSyntaxNode(0),null);
			object rt=LRParser.GetReductionSyntaxNode(0);
			if(LRParser.GetReductionSyntaxNode(1)!=null) {
				rt=LRParser.GetReductionSyntaxNode(1);
                if (LRParser.GetReductionSyntaxNode(1) is proc_block)
                {
                    add_lambda(LRParser.GetReductionSyntaxNode(1), _procedure_definition);//tasha 16.04.2010
                }
				if(LRParser.GetReductionSyntaxNode(1) is procedure_attribute) {
					procedure_header ph=_procedure_definition.proc_header;
					if(ph.proc_attributes==null) {
						ph.proc_attributes=new procedure_attributes_list();
						parsertools.assign_source_context(ph.proc_attributes,LRParser.GetReductionSyntaxNode(1));
					}
					ph.proc_attributes.proc_attributes.Add((procedure_attribute)LRParser.GetReductionSyntaxNode(1));
					parsertools.create_source_context(ph.proc_attributes,ph.proc_attributes,LRParser.GetReductionSyntaxNode(1));
				}
			}	
			parsertools.create_source_context(_procedure_definition,LRParser.GetReductionSyntaxNode(0),rt);
			
			return _procedure_definition;
		}*!


<proc_heading>
        ::= tkProcedure <proc_name> <fp_list> <maybe_error> <opt_meth_modificators> <opt_where_section>  !*3procedure_header<null,null,(method_name)$2,false,false,null,null> 
								object rt=$2;
								if($$.name.meth_name is template_type_name)
								{
									$$.template_args=($$.name.meth_name as template_type_name).template_args;
									ident id = new ident($$.name.meth_name.name);
									parsertools.create_source_context(id,$$.name.meth_name,$$.name.meth_name);
									$$.name.meth_name=id;
								}
								if ($3!=null) {
								  rt=$3;
		                                                  $$.parameters=(formal_parameters)$3;
								}
								if($4!=null)
									($4 as SyntaxError).bad_node=$$;
								if ($5!=null) {
								  rt=$5;
								  if (((procedure_attributes_list)$5).proc_attributes.Count>0) 
									$$.proc_attributes=(procedure_attributes_list)$5;
								}
								if ($6!=null) {
								  rt=$6;
								  $$.where_defs = (where_definition_list)$6;
								}
								parsertools.create_source_context($$,$1,rt);
								*!
!         |  tkProcedure <proc_name> tkEqual <qualified_identifier> tkSemiColon 
!         |  tkProcedure <proc_name> <error> <error_recovery> 

!<proc_name>
!        ::= <identifier>             <empty>                           !*0method_name<null,(ident)$1,null>*!
!         |  <visibility_specifier>   <empty>                           !*0method_name<null,(ident)$1,null>*!
!         |  <proc_name> tkPoint <identifier>                    !*{
!								method_name mn=(method_name)$1;
!								mn.class_name=mn.meth_name;
!								mn.meth_name=(ident)$3;
!								parsertools.create_source_context($1,$1,$3);
!								$$=$1;
!								}*!
!        |  <proc_name> tkPoint <visibility_specifier>          !*{
!								method_name mn=(method_name)$1;
!								mn.class_name=mn.meth_name;
!								mn.meth_name=(ident)$3;
!								parsertools.create_source_context($1,$1,$3);
!								$$=$1;
!								}*!
!

<proc_name>
	::= <func_name>

<func_name>
        ::= <func_meth_name_ident> <empty>                      	!*0method_name<null,(ident)$1,null>*!
         |  <func_class_name_ident> tkPoint <func_meth_name_ident>	!*0method_name<(ident)$1,(ident)$3,null>*!
         |  <func_class_name_ident> tkPoint <func_class_name_ident> tkPoint <func_meth_name_ident>	!*0method_name<(ident)$1,(ident)$5,(ident)$3>*!

<func_class_name_ident>
	::= <func_name_with_template_args>

<func_meth_name_ident>
	::= <func_name_with_template_args>
	 |  <operator_name_ident>


<func_name_with_template_args>
	::= <func_name_ident>
	 |  <func_name_ident> <template_arguments> 	!*3template_type_name<(ident_list)$2>
								$$.name=((ident)$1).name;
								parsertools.create_source_context($$,$1,$2);
							*!
<func_name_ident>
        ::= <identifier>
	 |  <visibility_specifier>




<func_heading>
        ::= tkFunction <func_name> <fp_list> tkColon <fptype> <opt_meth_modificators> <opt_where_section> !*3function_header<> 
								object rt=$2;
								$$.name=(method_name)$2;
								if($$.name.meth_name is template_type_name)
								{
									$$.template_args=($$.name.meth_name as template_type_name).template_args;
									ident id = new ident($$.name.meth_name.name);
									parsertools.create_source_context(id,$$.name.meth_name,$$.name.meth_name);
									$$.name.meth_name=id;
								}
								//$$.template_args=(ident_list)$3;
								if ($3!=null) {
								  rt=$3;
		                                                  $$.parameters=(formal_parameters)$3;
								}
								if ($5!=null) {
								  rt=$5;
								  $$.return_type=(type_definition)$5;
								}
								if ($6!=null) {
								  rt=$6;
								  if (((procedure_attributes_list)$6).proc_attributes.Count>0) 
									$$.proc_attributes=(procedure_attributes_list)$6;
								}
								if ($7!=null) {
								  rt=$7;
								  $$.where_defs = (where_definition_list)$7;
								}
								$$.of_object=false;
 								$$.class_keyword=false;
								parsertools.create_source_context($$,$1,rt);
								*!
         |  tkFunction <func_name> <opt_meth_modificators>              !*3function_header<> 
								object rt=$2;
								$$.name=(method_name)$2;
								if ($3!=null) {
								  rt=$3;
								  if (((procedure_attributes_list)$3).proc_attributes.Count>0) 
									$$.proc_attributes=(procedure_attributes_list)$3;
								}
								$$.of_object=false;
 								$$.class_keyword=false;
								parsertools.create_source_context($$,$1,rt);
								*!
!         |  tkFunction <func_name> tkEqual <qualified_identifier> tkSemiColon 
!         |  tkFunction <func_name> <error> <error_recovery> 


<proc_block>
        ::= <proc_block_decl> 
!         |  <inline_directr> tkSemiColon 

<func_block>
        ::= <proc_block_decl> 
!         |  <inline_directr> tkSemiColon 

<proc_block_decl>
        ::= <block> 
         |  <external_directr> 
         |  <asm_block>
!	 |  <bf_block>
         |  tkForward tkSemiColon              			!*$$=$1;*!

<abc_proc_block>
        ::= <abc_block> 
         |  <external_directr> 

<external_directr>
	::= <abc_external_directr>
	 |  <abc_external_directr> tkSemiColon 			!*$$=$1;*!
!        ::= tkExternal <external_directr_ident> <external_directr_2> 
!         |  tkExternal <external_directr_ident> <external_directr_2> tkSemiColon 
         |  tkExternal tkSemiColon !*3external_directive<null,null>
		 parsertools.create_source_context($$,$1,$1); *!
!
!<external_directr_2>
!        ::= 
!         |  tkName <external_directr_ident> 
!         |  tkIndex <external_directr_3> 
!
!<external_directr_3>
!	::= tkInteger 
!         |  tkMinus tkInteger 

<external_directr_ident>
	::= <identifier>
	 |  <literal>

<abc_external_directr>
	::= tkExternal <external_directr_ident> tkName <external_directr_ident> !*3external_directive<(expression)$2,(expression)$4> 
										parsertools.create_source_context($$,$1,$4);*!
	| tkExternal <external_directr_ident> !*3external_directive<(expression)$2,null>
										parsertools.create_source_context($$,$1,$2);*!

<asm_block>
	::= <impl_decl_sect_list> tkAsmBody tkSemiColon

!<bf_block>
!	::= tkBF <bf_instructions> tkEnd tkSemiColon 		!*3block<new declarations(),(statement_list)$2>
!								parsertools.create_source_context($$,$1,$4);
!								parsertools.create_source_context($2,$1,$3);
!								parsertools.create_source_context($$.defs,$1,$1);
!								//$$.defs.defs.Add()
!
!								*!
!<bf_empty_instruction>
!	::= 
!<bf_instructions>
!	::= <bf_instructions_list>                     		
!	 |  <bf_empty_instruction>  <empty>                            !*3statement_list<> $$.subnodes.Add(new empty_statement());*!
!<bf_instructions_list> 
!	::= <bf_instruction> <empty>                                   !*3statement_list<>
!								$$.subnodes.Add((statement)$1);
!								*!
!	 |  <bf_instructions_list> <bf_instruction>   		!*1statement_list<>$1;
!								$$.subnodes.Add((statement)$2);
!								*!
!<bf_instruction>  
!	::= tkGreater <empty>                				!*4IncCaret<>*!			! >  Increment p
!	 |  tkLower   <empty>                				!*4DecCaret<>*!			! <  Decrement p
!	 |  tkPlus    <empty>          				!*4IncCaretValue<>*!		! +  Increment *p
!	 |  tkMinus  	<empty>	        			!*4DecCaretValue<>*!		! -  Decrement *p
!	 |  tkPoint   <empty>    					!*4WriteCaretValue<>*!		! .  Output *p
!	 |  tkComma   <empty>                 				!*4ReadCaretValue<>*!		! ,  Input *p
!	 |  tkSquareOpen <bf_instructions> tkSquareClose	!*5CaretValueNotNull<>*!  	![ ] 
!	 |  tkDotDot  <empty>                 				!*4WriteCaretValue2<>*!  	! .. Output *p Output *p
!
!

<block>
        ::= <impl_decl_sect_list> <compound_stmt> tkSemiColon 	!*3block<(declarations)$1,(statement_list)$2>
								parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),$3);*!

<abc_block>
        ::= <abc_decl_sect_list> <compound_stmt> tkSemiColon  !*3block<(declarations)$1,(statement_list)$2>
								parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),$3);*!

<fp_list>
        ::= 
         |  tkRoundOpen <fp_sect_list> tkRoundClose    		!* if($2!=null) parsertools.create_source_context($2,$1,$3);
								$$=$2;*!
                                                       	
<fp_sect_list>
        ::= 
         |  <fp_sect>   <empty>                                        !*3formal_parameters<>
								$$.params_list.Add((typed_parameters)$1);
								*!
         |  <fp_sect_list> tkSemiColon <fp_sect>                !*1formal_parameters<>$1;
								$$.params_list.Add((typed_parameters)$3);	
								*!

<fp_sect>
	::= <opt_attribute_declarations> <simple_fp_sect> !*2declaration<> $$=$2 as declaration;
			$$.attributes = $1 as attribute_list;
		*!
	
<simple_fp_sect>
        ::= <param_name_list> tkColon <fptype_new>              !*0typed_parameters<(ident_list)$1,(type_definition)$3,parametr_kind.none,null>*!
         !|  <param_name_list> <empty>                                  !*0typed_parameters<(ident_list)$1,null,parametr_kind.none,null>*!
         |  tkVar <param_name_list> tkColon <fptype_new>        !*3typed_parameters<(ident_list)$2,(type_definition)$4,parametr_kind.var_parametr,null> parsertools.create_source_context($$,$1,$4);*!
         !|  tkVar <param_name_list> <empty>                            !*3typed_parameters<(ident_list)$2,null,parametr_kind.var_parametr,null> parsertools.create_source_context($$,$1,$2);*!
         |  tkOut <param_name_list> tkColon <fptype_new>        !*3typed_parameters<(ident_list)$2,(type_definition)$4,parametr_kind.out_parametr,null> parsertools.create_source_context($$,$1,$4);*!
         !|  tkOut <param_name_list> <empty>                            !*3typed_parameters<(ident_list)$2,null,parametr_kind.out_parametr,null> parsertools.create_source_context($$,$1,$2);*!
         |  tkConst <param_name_list> tkColon <fptype_new>      !*3typed_parameters<(ident_list)$2,(type_definition)$4,parametr_kind.const_parametr,null> parsertools.create_source_context($$,$1,$4);*!
         !|  tkConst <param_name_list> <empty>                          !*3typed_parameters<(ident_list)$2,null,parametr_kind.const_parametr,null> parsertools.create_source_context($$,$1,$2);*!
         |  tkParams <param_name_list> tkColon <fptype_new>     !*3typed_parameters<(ident_list)$2,(type_definition)$4,parametr_kind.params_parametr,null> parsertools.create_source_context($$,$1,$4);*!
         !|  tkParams <param_name_list> <empty>                         !*3typed_parameters<(ident_list)$2,null,parametr_kind.params_parametr,null> parsertools.create_source_context($$,$1,$2);*!
         |  <param_name_list> tkColon <fptype> tkAssign <const_expr> 		!*0typed_parameters<(ident_list)$1,(type_definition)$3,parametr_kind.none,(expression)$5>*!
         |  tkVar <param_name_list> tkColon <fptype> tkAssign <const_expr>	!*3typed_parameters<(ident_list)$2,(type_definition)$4,parametr_kind.var_parametr,(expression)$6> parsertools.create_source_context($$,$1,$6);*!
         |  tkOut <param_name_list> tkColon <fptype> tkAssign <const_expr>       !*3typed_parameters<(ident_list)$2,(type_definition)$4,parametr_kind.out_parametr,(expression)$6> parsertools.create_source_context($$,$1,$6);*!
         |  tkConst <param_name_list> tkColon <fptype> tkAssign <const_expr>     !*3typed_parameters<(ident_list)$2,(type_definition)$4,parametr_kind.const_parametr,(expression)$6> parsertools.create_source_context($$,$1,$6);*!

<param_name_list>
        ::= <param_name>   <empty>                                     !*6ident_list<idents>ident*!
         |  <param_name_list> tkComma <param_name>		!*7ident_list<idents>ident*!

<param_name>
        ::= <identifier> 

<fptype>                                                        
	::= <type_ref> 
!        ::= <identifier>                                        !* {if ($1 is known_type_definition) return $1;
!								named_type_reference ntr=new named_type_reference(null,(ident)$1);
!								parsertools.create_source_context(ntr,$1,$1);
!								return ntr;}
!								*!
!        |  <unit_name> tkPoint <identifier>                    !* {if ($3 is known_type_definition) {((known_type_definition)$3).unit_name=(ident)$1;return $3;}
!								named_type_reference ntr=new named_type_reference((ident)$1,(ident)$3);
!								parsertools.create_source_context(ntr,$1,$3);
!								return ntr;}
!								*!

<fptype_new>
	::= <type_ref>
	 |  tkArray tkOf tkConst                                !*3array_of_const_type_definition<> parsertools.create_source_context($$,$1,$3);*!

!        ::= <fptype> 
!         |  <fptype> tkEqual <const_expr> 
!         |  tkArray tkOf <fptype>                               !*3array_of_named_type_definition<(named_type_reference)$3> parsertools.create_source_context($$,$1,$3);*!

<stmt>
        ::= <unlabelled_stmt> 
         |  <label_name> tkColon <stmt> 			!*3labeled_statement<(ident)$1,(statement)$3> parsertools.create_source_context($$,$1,parsertools.sc_not_null($3,$2));*!

<unlabelled_stmt>
        ::= <empty> <empty>                                   	!*3empty_statement<>*!
         |  <assignment> 
         |  <proc_call> 
         |  <goto_stmt> 
         |  <compound_stmt> 
         |  <if_stmt> 
         |  <case_stmt> 
         |  <repeat_stmt> 
         |  <while_stmt> 
         |  <for_stmt> 
         |  <with_stmt> 
         |  <asm_stmt> 
!         |  <inline_directr> 
         |  <inherited_message>    				
         |  <try_stmt> 
         |  <raise_stmt>
	 |  <foreach_stmt>
	 |  <var_stmt>
	 |  <expr_as_stmt>
	 |  <lock_stmt>

<var_stmt>
	::= tkVar <var_decl_part_in_stmt>			!*3var_statement<$2 as var_def_statement> 
                                                       ///////////////tasha 28.04.2010
            pascalABC_var_statements.Add((var_def_statement)LRParser.GetReductionSyntaxNode(1));
            ///////////////////////////////
                                                       parsertools.create_source_context($$,$1,$2);*!


<assignment>
 	::= <var_reference> <assign_operator> <expr>            !*{
                                                        ///////////////tasha 28.04.2010
                                                        for_assignment(LRParser.GetReductionSyntaxNode(0), LRParser.GetReductionSyntaxNode(2));
                                                        ///////////////////////////////

			                                      assign _assign=new assign(LRParser.GetReductionSyntaxNode(0) as addressed_value,LRParser.GetReductionSyntaxNode(2) as expression,((op_type_node)LRParser.GetReductionSyntaxNode(1)).type);
			                                      parsertools.create_source_context(_assign,LRParser.GetReductionSyntaxNode(0),LRParser.GetReductionSyntaxNode(2));
			
			                                      return _assign;
		                                            }*!
!        ::= <expr> tkAssign <expr>  		   		!*0assign<null,(expression)$3>
!								if ($1 is addressed_value_funcname)
!									$$.to=(addressed_value)$1;
!								else
!									errors.Add(new Errors.bad_leftside_assigment(current_file_name,((syntax_tree_node)$1).source_context,$$));
!								*!
        
<proc_call>
	::= <var_reference> <empty>                                    !*0procedure_call<$1 as addressed_value>*!
!        ::= <expr> 		       				!*0procedure_call<>
!								if ($1 is addressed_value_funcname)
!									$$.func_name=(addressed_value)$1;
!								else
!									errors.Add(new Errors.statement_expected(current_file_name,((syntax_tree_node)$1).source_context,$$));
!								*!

<goto_stmt>
        ::= tkGoto <label_name> 				!*0goto_statement<(ident)$2> 
												   parsertools.create_source_context($$,$1,$2);*!

<compound_stmt>                                             
        ::= tkBegin <stmt_list> tkEnd 				!*
	 							parsertools.create_source_context($2,$1,$3);
								((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
								((statement_list)$2).right_logical_bracket=(syntax_tree_node)$3;
								$$=$2;
								*!
	! |  tkILCode				

<stmt_list>
        ::= <stmt> <empty>                                             !*3statement_list<>
								$$.subnodes.Add((statement)$1);
								parsertools.assign_source_context($$,$1); 
								*!
         |  <stmt_list> tkSemiColon <stmt>                      !*2statement_list<> $$=(statement_list)$1;
								if($$!=$3){
								$$.subnodes.Add((statement)$3);
								parsertools.create_source_context($$,$$,parsertools.sc_not_null($3,$2)); 
								}
								*!

<if_stmt>
        ::= tkIf <expr> <if_then_else_branch>                   !*((if_node)$3).condition=(expression)$2;
								parsertools.create_source_context($3,$1,$3);
								$$=$3;
								*!

<if_then_else_branch>
        ::= tkThen <then_branch>                             	!*3if_node<null,(statement)$2,null>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($2,$1));	
								*!
         |  tkThen <then_branch> tkElse <else_branch>           !*3if_node<null,(statement)$2,(statement)$4>
								parsertools.create_source_context($$,$3,parsertools.sc_not_null($4,$3));	
								*!

<then_branch>
        ::= <stmt> 

<else_branch>
        ::= <stmt> 

<case_stmt>
        ::= tkCase <expr> tkOf <case_list> <else_case> tkEnd 	!*3case_node<(expression)$2,$4 as case_variants,$5 as statement>
								parsertools.create_source_context($$,$1,$6);*! 							

<case_list>
        ::= <case_item> <empty>                                !*3case_variants<> 
								if ($1 is case_variant)
								{
									$$.variants.Add((case_variant)$1);
									parsertools.create_source_context($$,$1,$1);
								}*!
         |  <case_list> tkSemiColon <case_item>         	!*1case_variants<>$1;
								parsertools.create_source_context($$,parsertools.sc_not_null($1,$2),parsertools.sc_not_null($3,$2)); 							
								if ($3 is case_variant) $$.variants.Add((case_variant)$3);*!

<case_item>
        ::= <empty> <empty>                                    !*3empty_statement<>*!
         |  <case_label_list> tkColon <stmt>            	!*3case_variant<(expression_list)$1,(statement)$3> 
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($3,$2));*!

<case_label_list>
        ::= <case_label> <empty>                               !*6expression_list<expressions>expression*!
         |  <case_label_list> tkComma <case_label>      	!*7expression_list<expressions>expression*!

<case_label>
	::= <const_elem>
!        ::= <const_expr> 
!         |  <const_expr> tkDotDot <const_expr> 

<else_case>
        ::= 
         |  tkElse <stmt_list> 					!*$$=$2;*!

<repeat_stmt>
        ::= tkRepeat <stmt_list> tkUntil <expr>                	!*3repeat_node<(statement)$2,(expression)$4>
								((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
								((statement_list)$2).right_logical_bracket=(syntax_tree_node)$3;
                                                                parsertools.create_source_context($2,$1,$3);
								parsertools.create_source_context($$,$1,$4);	
								*!
<while_stmt>
        ::= tkWhile <expr> <opt_tk_do> <stmt>                     	!*3while_node<(expression)$2,(statement)$4,WhileCycleType.While>
								if ($3 == null)
								{
									file_position fp = ($2 as syntax_tree_node).source_context.end_position;
									syntax_tree_node err_stn = (syntax_tree_node)$4;
									if (err_stn == null)
										err_stn = (syntax_tree_node)$2;
									errors.Add(new Errors.PABCNETUnexpectedToken(current_file_name, StringResources.Get("TKDO"),new SourceContext(fp.line_num, fp.column_num+1, fp.line_num, fp.column_num+1, 0, 0),err_stn));
									parsertools.create_source_context($$,$1,parsertools.sc_not_null($2,$4));
								}
								else
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3));	
								*!

<opt_tk_do>
		::= tkDo
		|
		
<lock_stmt>
        ::= tkLock <expr> tkDo <stmt>    			!*3lock_stmt<(expression)$2,(statement)$4>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3));	
								*!
<foreach_stmt>
        ::= tkForeach <identifier> <foreach_stmt_ident_dype_opt> tkIn <expr> tkDo <stmt> !*3foreach_stmt<(ident)$2,(type_definition)$3,(expression)$5,(statement)$7>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($7,$6));	
								*!

         |  tkForeach tkVar <identifier> tkColon <type_ref> tkIn <expr> tkDo <stmt> !*3foreach_stmt<(ident)$3,(type_definition)$5,(expression)$7,(statement)$9>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($9,$8));	
								*!

<foreach_stmt_ident_dype_opt>
	::= tkColon <type_ref> 					!* $$=$2; *!
	 |
           
<for_stmt>
        ::= tkFor <opt_var> <identifier> <for_stmt_decl_or_assign> <expr> <for_cycle_type> <expr> <opt_tk_do> <stmt> !*3for_node<(ident)$3,(expression)$5,(expression)$7,(statement)$9,(for_cycle_type)$6,null,$4 as type_definition, $2!=null>
								if ($8 == null)
								{
									file_position fp = ($7 as syntax_tree_node).source_context.end_position;
									syntax_tree_node err_stn = (syntax_tree_node)$9;
									if (err_stn == null)
										err_stn = (syntax_tree_node)$7;
									errors.Add(new Errors.PABCNETUnexpectedToken(current_file_name, StringResources.Get("TKDO"),new SourceContext(fp.line_num, fp.column_num+1, fp.line_num, fp.column_num+1, 0, 0),err_stn));
									parsertools.create_source_context($$,$1,parsertools.sc_not_null($9,$7));
								}
								else
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($9,$8));	
								*!
<opt_var>
	::= tkVar !*$$=true;*!
	 |

<for_stmt_decl_or_assign>
	::= tkAssign 
	 |  tkColon <simple_type_identifier> tkAssign 		!*$$=$2;*!

<for_cycle_type>
        ::= tkTo                           	!* $$=for_cycle_type.to; *!
         |  tkDownto                            !* $$=for_cycle_type.downto; *!

<with_stmt>
        ::= tkWith <expr_list> tkDo <stmt>        		!*3with_statement<(statement)$4,(expression_list)$2>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3));*!	

<inherited_message>
        ::= tkInherited <empty>    				!*3inherited_message<> parsertools.assign_source_context($$,$1);*!

<try_stmt>
        ::= tkTry <stmt_list> <try_handler>		!*3try_stmt<((statement_list)$2),(try_handler)$3> 
							((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
							parsertools.create_source_context($2,$1,$2);
							parsertools.create_source_context($$,$1,$3);
							*! 

<try_handler>
        ::= tkFinally <stmt_list> tkEnd         	!*3try_handler_finally<(statement_list)$2> 
							((statement_list)$2).left_logical_bracket=(syntax_tree_node)$1;
							((statement_list)$2).right_logical_bracket=(syntax_tree_node)$3;
							parsertools.create_source_context($$,$1,$3);*!
         |  tkExcept <exception_block> tkEnd    	!*3try_handler_except<(exception_block)$2> parsertools.create_source_context($$,$1,$3);*!

<exception_block>
        ::= <exception_handler_list> <exception_block_else_branch> 		!*3exception_block<null,(exception_handler_list)$1,(statement_list)$2>
										parsertools.create_source_context($$,$1,parsertools.sc_not_null($2,$1));*!
         |  <exception_handler_list> tkSemiColon <exception_block_else_branch>  !*3exception_block<null,(exception_handler_list)$1,(statement_list)$3>
										parsertools.create_source_context($$,$1,parsertools.sc_not_null($3,$2));*!
         |  <stmt_list> <empty>							!*3exception_block<(statement_list)$1,null,null>
										if (((syntax_tree_node)$1).source_context!=null) parsertools.assign_source_context($$,$1);*!

!!!!!SR???<exception_handler_list>
!!!!!	::= <exception_handler_list1>

<exception_handler_list>
        ::= <exception_handler>  <empty>                          		!*6exception_handler_list<handlers>exception_handler*!
         |  <exception_handler_list> tkSemiColon <exception_handler>    !*7exception_handler_list<handlers>exception_handler*!

<exception_block_else_branch>
        ::= 
         |  tkElse <stmt_list>         				!*$$=$2;*!

<exception_handler>
        ::= tkOn <exception_identifier> tkDo <stmt>             !*3exception_handler<((exception_ident)$2).variable,((exception_ident)$2).type_name,(statement)$4>
								parsertools.create_source_context($$,$1,parsertools.sc_not_null($4,$3));*!

<exception_identifier>
        ::= <exception_class_type_identifier> <empty>                  		!*0exception_ident<null,(named_type_reference)$1>*!
         |  <exception_variable> tkColon <exception_class_type_identifier>	!*0exception_ident<(ident)$1,(named_type_reference)$3>*! 

<exception_class_type_identifier>
        ::= <simple_type_identifier> 

<exception_variable>
        ::= <identifier> 

<raise_stmt>                                           	
        ::= tkRaise <empty>                                    !*3raise_stmt<> parsertools.assign_source_context($$,$1);*!
         |  tkRaise <expr>                              !*3raise_stmt<(expression)$2,null> parsertools.create_source_context($$,$1,$2);*!
         |  tkRaise <expr> tkAt <expr>                  !*3raise_stmt<(expression)$2,(expression)$4> parsertools.create_source_context($$,$1,$4);*!

<asm_stmt>
        ::= tkAsmBody 

<expr_list>
        ::= <expr> <empty>                             	!*6expression_list<expressions>expression*!
         |  <expr_list> tkComma <expr>       	  	!*7expression_list<expressions>expression*!

<attr_expr_list>
		::= <expr_list>
		
<expr_as_stmt>
	::= <allowable_expr_as_stmt> <empty>		!*3expression_as_statement<(expression)$1> parsertools.create_source_context($$,$1,$1);*!

<allowable_expr_as_stmt>
	::= <new_expr>

<expr>
	::= <expr_l1>
	 |  <format_expr> 
        |  <func_decl_lambda> !*$$=$1;*!

<expr_l1>
	::= <relop_expr>
	 |  <question_expr>
!         |  <new_expr>


<sizeof_expr>
	::= tkSizeOf tkRoundOpen <simple_or_template_type_reference> tkRoundClose !*3sizeof_operator<(named_type_reference)$3,null> parsertools.create_source_context($$,$1,$4);*!

<typeof_expr>
	::= tkTypeOf tkRoundOpen <simple_or_template_type_reference> tkRoundClose !*3typeof_operator<(named_type_reference)$3> parsertools.create_source_context($$,$1,$4);*!

<question_expr>
	::= <expr_l1> tkQuestion <expr_l1> tkColon <expr_l1> 	!*3question_colon_expression<(expression)$1,(expression)$3,(expression)$5> parsertools.create_source_context($$,$1,$5);*!


<opt_ampersend>
	::= 
	 |  tkAmpersend


<simple_or_template_type_reference>
	::= <simple_type_identifier> 
	 |  <simple_type_identifier> <template_type_params> !*3template_type_reference<(named_type_reference)$1,(template_param_list)$2>
							    parsertools.create_source_context($$,$1,$2);
							    *!
	 |  <simple_type_identifier> tkAmpersend <template_type_params> !*3template_type_reference<(named_type_reference)$1,(template_param_list)$3>
							    parsertools.create_source_context($$,$1,$3);
							    *!

<opt_array_initializer>
        ::= tkRoundOpen <typed_const_list> tkRoundClose !*3array_const<(expression_list)$2>
							parsertools.create_source_context($$,$1,$3);*!
			|
			
							
<new_expr>
	::= <identifier> <simple_or_template_type_reference> <opt_expr_list_with_bracket> !*
							{
							named_type_reference ntr=(named_type_reference)$2;
							new_expr newexpr=new new_expr(ntr,$3 as expression_list,false,null);
							parsertools.create_source_context(newexpr,$1,parsertools.sc_not_null($3,$2));
							if (($1 as ident).name.ToLower()!="new")
								errors.Add(new Errors.PABCNETUnexpectedToken(current_file_name,";",((syntax_tree_node)$1).source_context,newexpr));
							$$=newexpr;
							}
							*!		
	 | <identifier> <array_name_for_new_expr> tkSquareOpen <expr_list> tkSquareClose <opt_array_initializer>!*
							{
							new_expr newexpr=new new_expr((type_definition)$2,$4 as expression_list,true,$6 as array_const);
							if ($6 != null)
								parsertools.create_source_context(newexpr,$1,$6);
							else
								parsertools.create_source_context(newexpr,$1,$5);
							if (($1 as ident).name.ToLower()!="new")
								errors.Add(new Errors.PABCNETUnexpectedToken(current_file_name,";",((syntax_tree_node)$1).source_context,newexpr));
							$$=newexpr;
							}
							*!		

<array_name_for_new_expr>
	::= <simple_type_identifier>
	 |  <unsized_array_type>

<opt_template_type_params>
        ::= 
	 |  <template_type_params> 	

<opt_expr_list_with_bracket>
	::= 
	 |  tkRoundOpen <opt_expr_list> tkRoundClose 	!*$$=$2;*!


<relop_expr>
        ::= <simple_expr> 		
         |  <simple_expr> <relop> <relop_expr> 	   			!*0bin_expr<(expression)$1,(expression)$3,((op_type_node)$2).type>*!

<format_expr> 
	::= <simple_expr> tkColon <simple_expr>                         !*0format_expr<(expression)$1,(expression)$3,null>*!
         |  <simple_expr> tkColon <simple_expr> tkColon <simple_expr>	!*0format_expr<(expression)$1,(expression)$3,(expression)$5>*! 

<relop>
        ::= tkEqual 
         |  tkNotEqual 
         |  tkLower 
         |  tkGreater 
         |  tkLowerEqual 
         |  tkGreaterEqual 
         |  tkIn 

<simple_expr>                                                    
        ::= <term>
         |  <simple_expr> <addop> <term>                       	!*0bin_expr<$1 as expression,$3 as expression,((op_type_node)$2).type>*!

<addop>
        ::= tkPlus 
         |  tkMinus 
         |  tkOr 
         |  tkXor 
	 |  tkCSharpStyleOr

<typecast_op>
	::= tkAs <empty>  					!* $$=op_typecast.as_op; *!
	 |  tkIs <empty>                                        !* $$=op_typecast.is_op; *!

<as_is_expr>
	::= <term> <typecast_op> <simple_or_template_type_reference>    	!*0typecast_node<(addressed_value)$1,(type_definition)$3,(op_typecast)$2>
								if (!($1 is addressed_value)) 
									errors.Add(new Errors.bad_operand_type(current_file_name,((syntax_tree_node)$1).source_context,$$));
								*!
<term>
        ::= <factor> 
	 |  <new_expr>
         |  <term> <mulop> <factor>                            	!*0bin_expr<$1 as expression,$3 as expression,((op_type_node)$2).type>*!
!SR!
         |  <as_is_expr>

<mulop>
        ::= tkStar 
         |  tkSlash 
         |  tkDiv 
         |  tkMod 
         |  tkShl 
         |  tkShr 
         |  tkAnd 
!         |  tkAs 

<default_expr>
	 ::=  tkDefault tkRoundOpen <simple_or_template_type_reference> tkRoundClose !*3default_operator<$3 as named_type_reference> parsertools.create_source_context($$,$1,$4);*! 

<factor>        
        ::= tkNil <empty>      				!*3nil_const<> parsertools.create_source_context($$,$1,$1);*!
	 |  <literal_or_number>
	 |  <default_expr>
         |  tkSquareOpen <elem_list> tkSquareClose      !*3pascal_set_constant<$2 as expression_list> parsertools.create_source_context($$,$1,$3);*!
         |  tkNot <factor> 				!*0un_expr<$2 as expression,((op_type_node)$1).type>*!
         |  <sign> <factor> 				!*0un_expr<$2 as expression,((op_type_node)$1).type>*!
         |  tkDeref <factor> 				!*3roof_dereference<> 
							$$.dereferencing_value=(addressed_value)$2;
							parsertools.create_source_context($$,$1,$2);*!
         | <var_reference>
         | tkRoundOpen <func_decl_lambda> tkRoundClose tkRoundOpen <expr_list> tkRoundClose !*{ function_lambda_definition fld = find_pascalABC_lambda_name(((ident)LRParser.GetReductionSyntaxNode(1)).name);
    														expression_list _expression_list = (expression_list)LRParser.GetReductionSyntaxNode(4);
    														function_lambda_definition _lambda_definition = fld;
    														function_lambda_call _lambda_call = new function_lambda_call(_lambda_definition, _expression_list);
    														_lambda_call.source_context = ((ident)LRParser.GetReductionSyntaxNode(1)).source_context;
    														return _lambda_call;}*!
	  
 
<literal_or_number>
        ::= <literal> 
	 |  <unsigned_number>

<var_reference>
        ::= <var_address> <variable>                    !*((get_address)$1).address_of=(addressed_value)$2;parsertools.create_source_context(NodesStack.Peek(),NodesStack.Peek(),$2);$$=NodesStack.Pop();*!
         |  <variable>
 

<var_address>
        ::= tkAddressOf <empty>                                !*3get_address<> parsertools.assign_source_context($$,$1); NodesStack.Push($$);*!
         |  <var_address> tkAddressOf                   !*3get_address<> ((get_address)$1).address_of=(addressed_value)$$;parsertools.create_source_context($$,$2,$2);*! 

<attribute_variable>
	::= <simple_type_identifier> <opt_expr_list_with_bracket>!*0attribute<null,(named_type_reference)$1,(expression_list)$2>
		if ($2 == null)
			parsertools.create_source_context($$,$1,$1);
	*!
	
<variable>
        ::= <identifier>
!         |  <identifier> tkAmpersend <template_type_params>    !*0ident_with_templateparams<(ident)$1,(template_param_list)$3> *!
	!SR!
!         |  <identifier> <template_type_params> <template_type_back_variables>        !*((template_param_list)$2).dereferencing_value=(addressed_value)$1;parsertools.create_source_context($2,$1,$2);$$=$2;*!
	 |  <operator_name_ident>
         |  tkInherited <identifier> 			!*3inherited_ident<> $$.name=((ident)$2).name; parsertools.create_source_context($$,$1,$2);*!
         |  tkRoundOpen <expr> tkRoundClose  		!*if (!build_tree_for_brackets) { parsertools.create_source_context($2,$1,$3);$$=$2;} else 
														{
															expression br_exp = new bracket_expr($2 as expression);
															parsertools.create_source_context(br_exp,$1,$3);
															$$=br_exp;
														}
													*!
	 |  <sizeof_expr>
	 |  <typeof_expr>
         |  tkRoundOpen tkRoundClose 
         |  <literal_or_number> tkPoint <identifier_or_keyword> !*0dot_node<(addressed_value)$1,(addressed_value)$3>*!
	 |  <variable> <var_specifiers>                 !*
							if ($2 is dot_node) 
							{
							  ((dot_node)$2).left=(addressed_value)$1;
							  parsertools.create_source_context($2,$1,((dot_node)$2).right);
							}
							else
							if ($2 is template_param_list) 
							{
							  ((dot_node)(((template_param_list)$2).dereferencing_value)).left=(addressed_value)$1;
                                                          parsertools.create_source_context($2,$1,$2);
							  parsertools.create_source_context(((template_param_list)$2).dereferencing_value,$1,((template_param_list)$2).dereferencing_value);
							}
							else
							if ($2 is dereference) 
							{
							  ((dereference)$2).dereferencing_value=(addressed_value)$1;
							  parsertools.create_source_context($2,$1,$2);
							}
							else
							if ($2 is ident_with_templateparams) 
							{
								((ident_with_templateparams)$2).name=(addressed_value_funcname)$1;
								parsertools.create_source_context($2,$1,$2);
							}
							$$=$2;
							*!

<opt_expr_list>
	::= <expr_list>
	 |

<opt_attr_expr_list>
	::= <attr_expr_list>
	|
	
<attribute_var_specifiers>
	::= tkRoundOpen <opt_attr_expr_list> tkRoundClose !*3method_call<$2 as expression_list> parsertools.create_source_context($$,$1,$3);*!
	|  tkPoint <identifier_keyword_operatorname> !*3dot_node<null,(addressed_value)$2> parsertools.create_source_context($$,$1,$2);*!
	
<var_specifiers>
        ::= tkSquareOpen <expr_list> tkSquareClose      !*3indexer<(expression_list)$2> parsertools.create_source_context($$,$1,$3);*!
         |  tkSquareOpen tkSquareClose 
         |  tkRoundOpen <opt_expr_list> tkRoundClose !*3method_call<$2 as expression_list> parsertools.create_source_context($$,$1,$3);*!                
	 |  tkPoint <identifier_keyword_operatorname>	!*3dot_node<null,(addressed_value)$2> parsertools.create_source_context($$,$1,$2);*!             
         |  tkDeref <empty>                             !*3roof_dereference<> parsertools.assign_source_context($$,$1);*!
	 |  tkAmpersend <template_type_params>          !*3ident_with_templateparams<null,(template_param_list)$2> parsertools.create_source_context($$,$1,$2);*!
	!SR!
!         |  <point_identifier_or_keyword> <template_type_params> <template_type_back_variables>	!*((template_param_list)$2).dereferencing_value=(addressed_value)$1;$$=$2;*!

!<template_type_back_variables>
!	::= <point_identifier_or_keyword>
!	 |  <template_type_back_variables> <template_type_back_varspecifiers>
!

<template_type_back_varspecifiers>	
	::= tkRoundOpen <expr_list> tkRoundClose        !*3method_call<(expression_list)$2> parsertools.create_source_context($$,$1,$3);*!
         |  tkRoundOpen tkRoundClose                    !*3method_call<> parsertools.create_source_context($$,$1,$2);*!


<elem_list>
        ::= <elem_list1> 
         |  

<elem_list1>
        ::= <elem>      <empty>	                       	!*6expression_list<expressions>expression*!
         |  <elem_list1> tkComma <elem> 		!*7expression_list<expressions>expression*!

<elem>
        ::= <expr>    
         |  <expr> tkDotDot <expr> 			!*0diapason_expr<(expression)$1,(expression)$3>*!

!<inline_directr>
!        ::= tkInline tkRoundOpen <inline_element> tkRoundClose 

!<inline_element>
!        ::= <inline_param> 
!         |  <inline_element> tkSlash <inline_param> 

!<inline_param>
!        ::= tkLower <inline_const> 
!         |  tkGreater <inline_const> 
!         |  <inline_param_variable> 

!<inline_param_variable>
!        ::= <var_reference> 
!         |  <inline_param_variable> <sign> <inline_const> 
!         |  tkHex 

!<inline_const>
!        ::= <const_factor> 

<one_literal>
        ::= tkStringLiteral 
         |  tkAsciiChar 

<literal>
	::=<literal_list> <empty>                      !* literal_const_line lcl=(literal_const_line)$1;
	                                        if (lcl.literals.Count==1) $$=lcl.literals[0];
						$$=lcl;
						*!
<literal_list>
        ::= <one_literal> <empty>           		!*0literal_const_line<>
						$$.literals.Add((literal)$1);
						*!
         |  <literal_list> <one_literal> 	!*1literal_const_line<>$1;
						$$.literals.Add((literal)$2);
						parsertools.create_source_context($$,$$,$2);
						*!

<operator_name_ident>
	::= tkOperator <overload_operator>			!*3operator_name_ident<((op_type_node)$2).type>
								$$.name=((op_type_node)$2).text;
								parsertools.create_source_context($$,$1,$2);*!
<opt_meth_modificators>
	::= tkSemiColon                                         !*3procedure_attributes_list<> parsertools.AddModifier($$,proc_attribute.attr_overload);  parsertools.create_source_context($$,$1,$1); *!
	 |  tkSemiColon <meth_modificators> tkSemiColon		!* parsertools.AddModifier((procedure_attributes_list)$2,proc_attribute.attr_overload); $$=$2; *!

<meth_modificators>
	::= <meth_modificator>	<empty>				!*6procedure_attributes_list<proc_attributes>procedure_attribute*!
         |  <meth_modificators> tkSemiColon <meth_modificator>	!*7procedure_attributes_list<proc_attributes>procedure_attribute*!

<integer_const>
        ::= <sign> tkInteger 
         |  tkInteger 
         |  <sign> tkHex 
         |  tkHex 
         |  <identifier> 
         |  <sign> <identifier> 


<identifier>
        ::= tkIdentifier 
         |  <real_type_name> 
         |  <ord_type_name> 
         |  <variant_type_name>
	 |  <meth_modificator> 
         |  <property_specifier_directives> 
         |  <non_reserved> 
         |  <other> 

<identifier_or_keyword>
	::= <identifier>
	 |  <keyword>       		<empty>        	!*3ident<($1 as token_info).text> parsertools.create_source_context($$,$1,$1);*!
	 |  <reserved_keyword>       	<empty>        	!*3ident<($1 as token_info).text> parsertools.create_source_context($$,$1,$1);*!

<identifier_keyword_operatorname>
	::= <identifier>
	 |  <keyword>       		<empty>        	!*3ident<($1 as token_info).text> parsertools.create_source_context($$,$1,$1);*!
	 |  <operator_name_ident> 	

<real_type_name>
        ::= tkReal 
         |  tkSingle 
         |  tkDouble 
         |  tkExtended 
         |  tkComp 

<ord_type_name>
        ::= tkShortInt 
         |  tkSmallInt 
         |  tkOrdInteger 
         |  tkByte 
         |  tkLongInt 
         |  tkInt64 
         |  tkWord 
         |  tkBoolean 
         |  tkChar 
         |  tkWideChar 
         |  tkLongWord 
         |  tkPChar 
         |  tkCardinal 

<variant_type_name>
        ::= tkVariant 
         |  tkOleVariant 

<meth_modificator>
	::= tkAbstract 
         |  tkOverload          
	 |  tkReintroduce
         |  tkOverride
         |  tkVirtual 
	 |  tkStatic
!	 |  tkForward

<property_specifier_directives>
        ::= tkRead 
         |  tkWrite 
         |  tkStored 
         |  tkNodefault 
         |  tkImplements 
         |  tkWriteOnly 
         |  tkReadOnly 
         |  tkDispid 

<non_reserved>
        ::= tkAt 
         |  tkAbsolute 
         |  tkOn 
         |  tkName 
         |  tkIndex 
         |  tkMessage 
         |  tkContains 
         |  tkRequires 
         |  tkForward 
         |  tkOut 

<visibility_specifier>
        ::= tkInternal 
         |  tkPublic 
         |  tkProtected 
         |  tkPrivate 

<other>
        ::= tkPackage 
         |  tkUnit 
         |  tkLibrary 
         |  tkExternal
	 |  tkParams

<keyword>
	::= <visibility_specifier> <empty> !*3token_info<($1 as ident).name> parsertools.create_source_context($$,$1,$1);*!
	 |  tkFinal
	 |  tkTemplate
	 |  tkOr
	 |  tkTypeOf
	 |  tkSizeOf
	 |  tkDefault
	 |  tkWhere
	 |  tkXor
	 |  tkAnd 		
	 |  tkDiv 		
	 |  tkMod 		
	 |  tkShl 		
	 |  tkShr 		
	 |  tkNot 		
	 |  tkAs 		
	 |  tkIn 		
	 |  tkIs 		
	 |  tkArray 	
	 |  tkBegin 	
	 |  tkCase  	
	 |  tkClass 	
	 |  tkConst 	
	 |  tkConstructor 	
	 |  tkDestructor 	
	 |  tkDownto 	
	 |  tkDo 		
	 |  tkElse 		
	 |  tkExcept  	
	 |  tkFile 		
	 |  tkFinalization 	
	 |  tkFinally 	
	 |  tkFor 		
	 |  tkForeach
	 |  tkFunction 	
	 |  tkIf
	 |  tkImplementation
	 |  tkInherited 	
	 |  tkInitialization
	 |  tkInterface 	
	 |  tkProcedure 	
	 |  tkProperty 	
	 |  tkRaise 	
	 |  tkRecord 	
	 |  tkRepeat 	
	 |  tkSet 		
	 |  tkTry 		
	 |  tkType 		
	 |  tkThen 		
	 |  tkTo 		
	 |  tkUntil 	
	 |  tkUses 		
	 |  tkUsing 	
	 |  tkVar 		
	 |  tkWhile		
	 |  tkWith 		
	 |  tkNil 		
	 |  tkGoto 		
	 |  tkOf 		
	 |  tkLabel 	
         |  tkProgram 

<reserved_keyword>
	::= tkOperator 	
         |  tkEnd

<overload_operator>
	::= tkMinus
	 |  tkPlus
	 |  tkSquareOpen tkSquareClose 
	 |  tkRoundOpen tkRoundClose
	 |  tkSlash 	
	 |  tkStar 	
	 |  tkEqual 		
	 |  tkGreater 		
	 |  tkGreaterEqual 		
	 |  tkLower 		
	 |  tkLowerEqual 		
	 |  tkNotEqual 		
	 |  tkOr 			
	 |  tkXor 			
	 |  tkAnd 			
	 |  tkDiv 			
	 |  tkMod 			
	 |  tkShl 			
	 |  tkShr 			
	 |  tkNot 			
	 |  tkIn 			
	 |  tkAddressOf
	 |  tkDeref
	 |	tkImplicit
	 | 	tkExplicit
	 |  <assign_operator>

<assign_operator>
	::= tkAssign
	 |  tkPlusEqual
	 |  tkMinusEqual
	 |  tkMultEqual
         |  tkDivEqual



<empty>  		
	::=

<error>
	::= tkError

<func_decl_lambda> ::= <ident_list1> tkArrow <lambda_body> !*{return func_decl_lambda(LRParser.GetReductionSyntaxNode(0), LRParser.GetReductionSyntaxNode(2));}*!
			| tkArrow <lambda_body>                !*{return func_decl_lambda(null, LRParser.GetReductionSyntaxNode(1));}*!
			| tkRoundOpen tkRoundClose tkArrow <lambda_body>  !*{return func_decl_lambda(null, LRParser.GetReductionSyntaxNode(3));}*!

<ident_list1> ::= tkRoundOpen <identifier> tkComma <ident_list2> tkRoundClose !*{return ident_list11(LRParser.GetReductionSyntaxNode(1), LRParser.GetReductionSyntaxNode(3));}*!
                | <identifier> <empty>  !*{return ident_list12(LRParser.GetReductionSyntaxNode(0));}*!
		  | tkRoundOpen <identifier> tkColon <fptype> tkComma <ident_list2> tkRoundClose !*{return ident_list13(LRParser.GetReductionSyntaxNode(1), LRParser.GetReductionSyntaxNode(3), LRParser.GetReductionSyntaxNode(5));}*!
                | tkRoundOpen <identifier> tkColon <fptype> tkRoundClose  !*{return ident_list14(LRParser.GetReductionSyntaxNode(1), LRParser.GetReductionSyntaxNode(3));}*!

<ident_list2> ::= <ident_list2> tkComma <var_or_identifier>  !*{return ident_list21(LRParser.GetReductionSyntaxNode(0), LRParser.GetReductionSyntaxNode(2));}*!
		  | <var_or_identifier> <empty>                !*{return ident_list12(LRParser.GetReductionSyntaxNode(0));}*!

<var_or_identifier> ::= <identifier>                    !*$$=$1;*!
                      | <identifier> tkColon <fptype>   !*{
            named_type_reference n_t_r = (named_type_reference)LRParser.GetReductionSyntaxNode(2);
            var_def_statement vds = new var_def_statement();
            vds.vars = new ident_list();
            vds.vars.idents.Add((ident)LRParser.GetReductionSyntaxNode(0));
            vds.vars_type = n_t_r;
            return vds;
        }*!

<lambda_body> ::= <expr_l1> <empty> !*{
statement_list _statement_list = new statement_list();
    ident id = new ident("result");
    op_type_node _op_type_node = new op_type_node(Operators.Assignment);
    _op_type_node.source_context = parsertools.GetTokenSourceContext();
    assign _assign = new assign((addressed_value)id, LRParser.GetReductionSyntaxNode(0) as expression, _op_type_node.type);
    parsertools.create_source_context(_assign, id, LRParser.GetReductionSyntaxNode(0));
    _statement_list.subnodes.Add((statement)_assign);
    parsertools.assign_source_context(_statement_list, _assign);
    parsertools.create_source_context(_statement_list, null, null);
    //block _block = new block(null, _statement_list);
   return _statement_list;
}
*!
		  | <compound_stmt> <empty> !*$$=$1;*!
